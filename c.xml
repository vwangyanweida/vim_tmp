<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE article>
<article
  xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xlink="http://www.w3.org/1999/xlink" >
  <info>
    <title></title>
  </info>
<section xml:id="快速掌握一个语言的50">
  <title>快速掌握一个语言的50%</title>
  <para>
    <font color=green></font> <font color=red></font>
  </para>
  <section xml:id="一.-printf函数和基础">
    <title>一. printf函数和基础</title>
    <section xml:id="printf和scanf">
      <title>1. printf和scanf</title>
      <section xml:id="打印浮点数时f默认显示小数点后6位如果强制f显示小数点后p位数字可以把.p放置在和f之间.2f">
        <title>1.
        打印浮点数时:%f,默认显示小数点后6位，如果强制%f显示小数点后p位数字，可以把.p放置在%和f之间。：%.2f</title>
        <para>
        </para>
      </section>
      <section xml:id="m.px格式m和p都是可选的如果省略pm和p之间的小数点也要去掉">
        <title>2.
        %m.pX格式：m和p都是可选的。如果省略p，m和p之间的小数点也要去掉。</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              m是最小字段宽度，如果要显示的数值所需的字符小于m，那么值在字段内是右对齐的，就是在值前面放置额外的空格
            </para>
          </listitem>
          <listitem>
            <para>
              如果大于m，则会自动扩展所需尺寸。
            </para>
          </listitem>
          <listitem>
            <para>
              %-m.pX中，值是左对齐的，空格加在后面。
            </para>
          </listitem>
          <listitem>
            <para>
              精度
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  如果X是d，p指明最小显示的数字个数，如果p省略，默认p为1
                </para>
              </listitem>
              <listitem>
                <para>
                  如果X是e，p指明小数点后应该出现的数字的个数，默认为6，如果p为0，不显示小数点。
                </para>
              </listitem>
              <listitem>
                <para>
                  如果X是f，<quote>定点十进制</quote>形式浮点数，没有之术。与e一样
                </para>
              </listitem>
              <listitem>
                <para>
                  如果X是g，<quote>定点十进制</quote>或者指数形式，p表示可以显示的有效数字，不显示尾随的0.
                  #### 3. scanf：
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              scanf第二个参数是一个指针，一定要注意。
            </para>
          </listitem>
          <listitem>
            <para>
              scanf会忽略所有空白字符。
            </para>
          </listitem>
          <listitem>
            <para>
              scanf 输入字符串时不会忽略空白字符。？？？
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="易混淆">
        <title>4. 易混淆</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              printf的参数没有指针
            </para>
          </listitem>
          <listitem>
            <para>
              scanf中的格式串不能包含逗号，scanf(%d, %d, &amp;i,
              &amp;j)。如果输入第一个整数后没有跟着一个逗号，scanf会出现异常。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="读写字符串">
        <title>5. 读写字符串</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              printf函数会逐个写字符串中的字符，知道遇到空字符才停止(如果空字符丢失，printf函数会越过字符串的末尾继续写，直到最终在内存的某个地方找到空字符为止。)
            </para>
            <programlisting>
 char str[] = &quot;abcd&quot;;
 printf(&quot;%s\n&quot;, str);
</programlisting>
          </listitem>
          <listitem>
            <para>
              如果指向显示字符串的一部分，可以使用转换说明符
              %.ps,这里p是要显示的字符数量。
            </para>
            <programlisting>
 printf(&quot;%.6s\n&quot;, str);
</programlisting>
          </listitem>
          <listitem>
            <para>
              字符串的打印也适用于: %m.px 模式
            </para>
          </listitem>
          <listitem>
            <para>
              puts(str):puts只有一个参数，即需要显示的字符串，会自动加一个换行符
            </para>
          </listitem>
          <listitem>
            <para>
              转换说明%s允许scanf函数把字符串读入字符数组：
            </para>
            <programlisting>
 scanf(&quot;%s&quot;, str);
</programlisting>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  str不需要加&amp;运算符，因为str是数组名，编译器把它传递给函数时会把它当做指针来处理。
                </para>
              </listitem>
              <listitem>
                <para>
                  scanf函数会跳过空白字符，然后读入字符并存储到str中，知道遇到空白字符为止，scanf始终会在字符串末尾存储一个空字符
                </para>
              </listitem>
              <listitem>
                <para>
                  用scanf函数读入字符串永远不会包含空白字符，因此，scanf函数通常不会读入一整行输入。
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=green>换行符会使scanf停止读入，空格符或制表符也会产生同样的结果</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              为了一次读入一整行输入，可以使用gets函数，gets把读入的字符放到数组中，然后添加空字符。
            </para>
          </listitem>
          <listitem>
            <para>
              gets和scanf的区别：
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  gets函数不会在开始读入字符串之前跳过空白字符(scanf函数会跳过)
                </para>
              </listitem>
              <listitem>
                <para>
                  gets函数会持续读入直到找到换行符才停止(scanf函数会在任意空白字符出停止).此外，gets函数会忽略掉换行符，不会存储到字符数组，并用空字符代替。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              输入越界
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  <font color=red>再把字符读入数组时，scanf和gets都无法检测数组何时被填满，scanf可以通过%ns替换%s来制定可以存储的最多的字符数。但gets天生不安全，fgets函数则是一种好选择</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              逐个字符读字符串。
            </para>
            <programlisting>
 int read_line(char str[], int n){
     int ch, i = 0;
     while (i &lt; n)
         if ((ch = getchar()) != '\n')
           str[i++] = ch;
    str[i] = '\0';
    return i;
 }
</programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="基本数据结构">
      <title>2. 基本数据结构</title>
      <section xml:id="整数intunsigned-intlonglong-longchar">
        <title>1. 整数：int，unsigned int，long，long long，char</title>
        <para>
        </para>
      </section>
      <section xml:id="float-double">
        <title>2. float， double</title>
        <para>
        </para>
      </section>
    </section>
    <section xml:id="基本语法">
      <title>3. 基本语法</title>
      <section xml:id="表达式">
        <title>1. 表达式</title>
        <blockquote>
          <para>
            表达式是表示如何计算值的公式。
          </para>
        </blockquote>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              <font color=red>运算符</font>
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  算术运算符
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      加减乘除、求余、正负。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      /：当两个操作数都是整数时，运算符/会丢掉分数部分来<quote>截取</quote>结果。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      %：两个操作数都必须是整数，如果有一个不是整数，无法通过编译。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      / 和% 的分母不能为0.
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <emphasis role="strong">当/和%
                      用于负数操作数时，C99规定，除法的结果总是向零截取的。</emphasis>
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  关系运算符
                </para>
              </listitem>
              <listitem>
                <para>
                  逻辑运算符
                </para>
              </listitem>
              <listitem>
                <para>
                  逗号云算法
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      语法： 表达式1， 表达式2
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      解释：
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          逗号表达式的计算要通过两步来实现：
                        </para>
                        <orderedlist numeration="arabic" spacing="compact">
                          <listitem>
                            <para>
                              计算表达式1并且扔掉计算出的值。
                            </para>
                          </listitem>
                          <listitem>
                            <para>
                              计算表达式2，把这个值作为整个表达式的值。
                            </para>
                          </listitem>
                          <listitem>
                            <para>
                              对表达式1的计算应该始终会有副作用，如果没有，那么表达式1就没有了存在的意义。
                            </para>
                          </listitem>
                        </orderedlist>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              运算符的优先级和结核性
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  最高：正负
                </para>
              </listitem>
              <listitem>
                <para>
                  最低： + -
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=green>二元算术符是左结合的</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=green>一元算术符是右结合的，复制操作符=也是右结合的。</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=red>赋值运算符=在C中是运算符，换句话说，复制操作符产生结果，就像如果两个数相加产生结果一样。赋值表达式v=e的值就是赋值运算后v的值。这个表达式是产生一个结果的，所以可以连等就是这个原因。</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  关系运算符低于算术运算符，关系运算符是左结合的。
                </para>
              </listitem>
              <listitem>
                <para>
                  判等运算符，==。左结合，优先级低于关系运算符。
                </para>
              </listitem>
              <listitem>
                <para>
                  逻辑运算符：!, &amp;&amp;, ||.
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      结果为0或者1
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      将任何非零操作数作为真值来处理，同时将任何零值操作数当做假来处理。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      &amp;&amp; 和||
                      都对操作数进行<quote>短路</quote>计算。短路操作的副作用是不计算右边的表达式时，如果右边的表达式改变了变量的值，就没有计算这个表达式
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      ! 的优先级和一元正负号一样。&amp;&amp;
                      和||优先级低于 关系运算符好判等运算符。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              左值 &gt;
              左值表示存储在计算机内存中的对象，而不是常量或计算的结果，变量时已知的唯一左值。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  赋值运算符要求左操作数必须是左值。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              自增自减
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
<literallayout>i++：先用i的原始值，稍后再自增i。稍后是指在校一条指令执行之前。
</literallayout>
              </listitem>
              <listitem>
                <para>
                  ++i：立即自增i。
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=red>后缀++和后缀–比一元的正号和负号优先级高而且都是左结合的</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=red>前缀++和前缀–和一元的正号和负号优先级相同而且都是右结合的</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="语句">
        <title>2. 语句</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              选择语句
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  if
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      级联式if。 if …… else if …… else
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      避免悬空式else。最好加上大括号。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      条件表达式： 表达式1 ? 表达式2 : 表达式3
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          条件运算符的优先级低于前面介绍过的所有运算符。
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                  <listitem>
                    <para>
                      布尔值：C99
                      定义了一个_Bool类型，其实是int但只能赋值0和1.
                    </para>
                    <orderedlist numeration="arabic">
                      <listitem>
                        <para>
                          一般来说，往_Bool变量中存储非零值会导致变量赋值为1；
                        </para>
                        <programlisting>
 flag = 5; /*flag is assigned 1*/
</programlisting>
                      </listitem>
                      <listitem>
                        <para>
                          除了_Bool这个类型外，C99还提供了一个新的头文件&lt;stdbool.h&gt;,这使得操作布尔值更加容易。该头文件提供了bool宏，用来代表_Bool.
                        </para>
                        <programlisting>
 #include&lt;stdbool.h&gt;
 flag = false
 flag = true
</programlisting>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  switch
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      语法：
                    </para>
                    <programlisting>
 switch (表达式) {
     case 常量表达式: 语句；
             语句；
             语句；
             break；
     case 常量表达式: 语句；
             语句：语句；
             语句；
             break；
             ……
     default：语句；
              语句；
              break；
 }
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  switch
                  表达式必须是整形表达式，C语言吧字符也当成字符，所以字符也可以。浮点数和字符串不可以。
                </para>
              </listitem>
              <listitem>
                <para>
                  常量表达式不能包含变量和函数调用，也必须是整数。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="重复语句">
        <title>2. 重复语句</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              while
            </para>
            <programlisting>
 while （表达式） 语句
</programlisting>
          </listitem>
          <listitem>
            <para>
              do
            </para>
            <programlisting>
 do 语句 while (表达式);  注意这里有分隔号。
</programlisting>
          </listitem>
          <listitem>
            <para>
              for
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  语法 for （表达式1；表达式2；表达式3） 语句
                </para>
              </listitem>
              <listitem>
                <para>
                  for 条件表达式可以省略其他语句。但分号要保留。
                </para>
              </listitem>
              <listitem>
                <para>
                  for语句声明的变量不可以在循环外访问。在循环外不可见。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="跳转语句">
        <title>3. 跳转语句</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              break
            </para>
          </listitem>
          <listitem>
            <para>
              continue
            </para>
          </listitem>
          <listitem>
            <para>
              goto
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  语法：
                </para>
                <programlisting>
 标识符 : 语句
 goto 标识符；
</programlisting>
              </listitem>
              <listitem>
                <para>
                  一般不用，在多层循环嵌套时，因为break跳不出最外层循环，可以使用。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="复合语句">
        <title>4. 复合语句</title>
        <blockquote>
          <para>
            几条语句组合成一条语句
          </para>
        </blockquote>
      </section>
      <section xml:id="空间语句">
        <title>5. 空间语句</title>
        <blockquote>
          <para>
            不执行任何语句
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              和python 的pass类似。 仅仅只有一个 分号： ；。
            </para>
          </listitem>
          <listitem>
            <para>
              空语句要单独一行写，否则阅读时会混淆。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="函数">
        <title>3. 函数</title>
        <para>
        </para>
      </section>
      <section xml:id="调用函数时是将实参的值复制给形参的所以函数如果想改变函数体外的变量需要使用引用或者指针">
        <title>1.
        调用函数时，是将实参的值复制给形参的。所以函数如果想改变函数体外的变量需要使用引用或者指针。</title>
        <para>
        </para>
      </section>
      <section xml:id="函数定义">
        <title>2. 函数定义</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              函数的返回类型
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  函数不能返回数组，但关于返回类型没有其他限制。
                </para>
              </listitem>
              <listitem>
                <para>
                  如果省略返回类型，C89会假定为int，但C99是不合法的。
                  #### 3. 函数声明 &gt;
                  在调用一个函数前，需要先声明函数或者定义函数。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              语法： [函数声明] 返回类型 函数名 (形式参数)
            </para>
          </listitem>
          <listitem>
            <para>
              函数声明和函数定义一定要一致。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="c语言中实际参数是通过值传递的">
        <title>4.
        <font color=green>C语言中，实际参数是通过值传递的</font></title>
        <para>
        </para>
      </section>
      <section xml:id="实际参数">
        <title>5. 实际参数</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              数组型实际参数
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  当形式参数是一维数组时，可以不说明数组的长度
                </para>
                <programlisting>
 int f(int a[])
 {
     ……
 }
</programlisting>
              </listitem>
              <listitem>
                <para>
                  <font color=red>C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来</font>
                </para>
                <programlisting>
 int sum_array(int a[], int n)
 {
     int i, sum = 0;
     for (i = 0; i &lt; n; i++)
         sum += a[i];
     return sum;
 }
</programlisting>
              </listitem>
              <listitem>
                <para>
                  在调用函数时，把数组名传递给函数时，不要在数组名的后边放置方括号，形参需要加。
                </para>
              </listitem>
              <listitem>
                <para>
                  在调用函数时，数组型实际参数的元素可以修改。值传递不包括数组名是因为数组名实际是一个指针。
                </para>
              </listitem>
              <listitem>
                <para>
                  如果形式参数是多维数组，生命参数时只能省略第一维的长度。
                </para>
                <programlisting>
 #define LEN 10
 int sum_two_dimensional_array(int a[][LEN], int n)
 {
 }
</programlisting>
              </listitem>
              <listitem>
                <para>
                  变长数组形式参数 &gt; C99
                  增加的变长数组允许我们使用非常量表达式指定数组的长度，变长数组也可以作为参数。
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      eg
                    </para>
                    <programlisting>
 int sum_array(int n, int a[n])
 {
 }
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      注意:确定数组长度的变量一定要出现在数组前面，因为运行时当执行到为数组分配空间时，数组长度需要确定，所以n的值当时应该已经知道。而且，如果n在后面会引起使用未定义的变量。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      函数声明(函数原型)有好几种写法：
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          int sum_array(int n, int a[n]);
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          int sum_array(int n, int a[*]);
                          //星号的使用告诉编译器–数组的长度与形式参数列表中前面的参数相关。
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          int sum_array(int, int [*]);
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          int sum_array(int n, int a[])
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          int sum_array(int, int []);
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                  <listitem>
                    <para>
                      变长数组形式参数的长度可以是任意表达式
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          int sum_two_dimensional_array(int n, int m,
                          int a[n][m]);
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  <font color=red>在数组参数声明中使用static</font>
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      C99允许在数组参数声明中使用关键字static。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      例子：将static放在数字3之前表明数组a的长度至少可以保证是3：
                    </para>
                    <programlisting>
 int sum_array(int a[static 3], int n)
 {
 }
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      static
                      不会对程序的行为有任何影响，static的存在只不过是一个<quote>提示</quote>，C编译器可以据此生成更快的指令来访问数组。
                      4.例如如果编译器知道数组总是具有某个最小值，那可他可以在函数调用时预先从内存中取出这些元素值，而不是在遇到函数内部实际需要用到这些元素的语句时采取出相应的值。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      <font color=red>如果数组名参数是多维的，static仅可用于第一维。</font>
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  复合字面量 &gt;
                  复合字面量是通过制定其包含的元素而创建的没有名字的数组。
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      total = sum_array((int[]){3, 0, 4, 5, 2}, 5);
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      函数内部创建的复合字面量可以包含任意的表达式，不限于常量
                    </para>
                    <programlisting>
 total = sum_array((int []){2*i, i+j, j*k}, 3);
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      复合字面量可以使用初始化式、可以不提供完全的初始化(未初始化的元素默认为0)
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      复合字面量是左值
                      ，所以元素是可以改变的，如果要求是<quote>只读</quote>的，可以在类型前加上const，如(const
                      int []){4, 5}.
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="程序终止">
        <title>4. 程序终止</title>
        <para>
        </para>
      </section>
      <section xml:id="main-函数的返回类型是int">
        <title>1. main 函数的返回类型是int</title>
        <para>
        </para>
      </section>
      <section xml:id="main函数返回的值是状态码在某些操作系统中程序终止时可以检测到状态码">
        <title>2.
        main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。</title>
        <para>
        </para>
      </section>
      <section xml:id="exit函数stdlib.h头文件-传递给exit的参数和main函数返回值具有相同含义">
        <title>3. exit函数，&lt;stdlib.h&gt;头文件。
        传递给exit的参数和main函数返回值具有相同含义。</title>
        <para>
        </para>
      </section>
      <section xml:id="main函数中的语句-return表达式等价于-exit表达式">
        <title>4. main函数中的语句 return表达式；等价于
        exit(表达式)</title>
        <para>
        </para>
      </section>
      <section xml:id="return和exit的差异不管那个函数调用exit函数都会导致程序终止return语句仅当有main函数调用时才会导致程序终止">
        <title>5.
        return和exit的差异：不管那个函数调用exit函数都会导致程序终止，return语句仅当有main函数调用时才会导致程序终止。</title>
        <para>
        </para>
      </section>
      <section xml:id="reurn后可以跟表达式return会先计算表达式再返回return后可以跟三元操作符">
        <title>6.
        reurn后可以跟表达式，return会先计算表达式再返回。return后可以跟三元操作符。</title>
        <para>
        </para>
      </section>
      <section xml:id="问答">
        <title>5. 问答</title>
        <para>
        </para>
      </section>
      <section xml:id="编译器把不跟圆括号的函数名看做是指向函数的指针">
        <title>1.
        编译器把不跟圆括号的函数名看做是指向函数的指针。</title>
        <para>
        </para>
      </section>
      <section xml:id="为什么要提供函数原型只要把所有函数的定义放置在main函数之前不就没有问题了吗">
        <title>2.
        为什么要提供函数原型，只要把所有函数的定义放置在main函数之前，不就没有问题了吗？</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              答：错。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  某些函数相互调用，这时无论先定义那一个都会导致问题
                </para>
              </listitem>
              <listitem>
                <para>
                  需要仔细斟酌函数定义的顺序以满足调用顺序
                </para>
              </listitem>
              <listitem>
                <para>
                  程序达到一定规模，在一个文件中放置所有函数是不可行的。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="为什么可以留着数组中第一维的参数不进行说明但是其他维数必须说明呢">
        <title>3.
        为什么可以留着数组中第一维的参数不进行说明，但是其他维数必须说明呢？</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              答：
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  传递的数组名其实是把指向数组的第一个元素的指针传递给了函数，而编译器计算a[i]
                  的地址时，
                  方法是用i乘以每个元素的大小并加到a表示的地址上。
                </para>
              </listitem>
              <listitem>
                <para>
                  多维数组的计算方式是：a[i][i]的地址是：i乘以数组a的每行的大小加上i乘以a每一个元素的大小并加到a表示的地址上，所以必须需要数组每一行的大小。
                </para>
              </listitem>
              <listitem>
                <para>
                  所以底线是程序员必须声明数组a拥有的列的数量。 #### 4.
                  如果函数f1调用函数f2，而函数f2又调用了f1，这样合法吗？
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              答：合法，这是一种间接递归的形式。
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="主要语言构造">
      <title>3. 主要语言构造</title>
      <section xml:id="指令">
        <title>1. 指令</title>
        <blockquote>
          <para>
            我们把预处理器执行的命令成为指令
          </para>
        </blockquote>
      </section>
      <section xml:id="所有指令都以字符开始指令默认只占一行每条指令的结尾没有分号或其他特殊标记">
        <title>1.
        所有指令都以#字符开始，指令默认只占一行，每条指令的结尾没有分号或其他特殊标记。</title>
        <para>
        </para>
      </section>
      <section xml:id="函数-1">
        <title>2. 函数</title>
        <blockquote>
          <para>
            函数类似于其他语言的<quote>过程</quote>或<quote>子例程</quote>，它们是用来构建程序的构建块。
          </para>
        </blockquote>
      </section>
      <section xml:id="语句-1">
        <title>3. 语句</title>
        <blockquote>
          <para>
            语句是程序运行时执行的命令
          </para>
        </blockquote>
      </section>
      <section xml:id="c语言规定每条语句都要以分号结尾但是有一个例外复合语句就不以分号结尾">
        <title>1.
        <font color=red>C语言规定每条语句都要以分号结尾,但是有一个例外：复合语句就不以分号结尾。</font></title>
        <para>
        </para>
      </section>
      <section xml:id="指令因为多是一行所以不用分号结尾而语句可能跨越多行需要表示分隔">
        <title>2.
        <font color=green>指令因为多是一行，所以不用分号结尾，而语句可能跨越多行，需要表示分隔</font></title>
        <para>
        </para>
      </section>
      <section xml:id="注释">
        <title>4. 注释</title>
        <para>
        </para>
      </section>
      <section xml:id="单行">
        <title>1. //单行</title>
        <para>
        </para>
      </section>
      <section xml:id="可以有多种方式">
        <title>2. <literal>/*  */</literal>可以有多种方式。</title>
        <para>
        </para>
      </section>
      <section xml:id="变量和赋值">
        <title>5. 变量和赋值</title>
        <para>
        </para>
      </section>
      <section xml:id="类型">
        <title>1. 类型：</title>
        <blockquote>
          <para>
            类型用来说明变量所存储的数据种类
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              <font color=red>每一个变量都必须有一个类型</font>
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=green>
              类型告诉编译器此变量需要占据多大的内存空间，类型确定了，C语言变量的存储空间大小就确定了。</font>
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=green>类型会影响变量的存储方式以及允许对变量进行的操作</font>
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="声明">
        <title>2. 声明</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              <font color=green>C语言使用变量之前必须对其进行声明</font>
            </para>
          </listitem>
          <listitem>
            <para>
              main函数包含声明时，必须把声明放置在语句之前，函数和程序块也一样。
            </para>
          </listitem>
          <listitem>
            <para>
              C++和Java程序中在使用时才声明变量。
            </para>
          </listitem>
          <listitem>
            <para>
              作用
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  告诉编译器，这个名字已经匹配到一块内存空间。
                </para>
              </listitem>
              <listitem>
                <para>
                  告诉编译器，这个名字已经预定了，其他地方不能在使用它声明变量或对象名。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              声明可以多次，定义只能一次，变量的生命和定义是一样的，一般用在函数声明和定义上。
            </para>
          </listitem>
          <listitem>
            <para>
              除了动态内存，变量在声明时就分配了内存空间。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="赋值">
        <title>3. 赋值</title>
        <blockquote>
          <para>
            变量通过赋值的方式获得值
          </para>
        </blockquote>
      </section>
      <section xml:id="初始化">
        <title>4. 初始化</title>
        <blockquote>
          <para>
            <font color=green>当程序执行时，某些变量会被自动初设置为0，而大多数变量则不会，没有默认值并且尚未在程序中被赋值的变量时未初始化的。</font>
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              <font color=red>方位未初始化的便令，可能会得到不可知的结果</font>
            </para>
          </listitem>
          <listitem>
            <para>
              解决方法
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  在变量声明中加入初始值。
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      int height = 8； 8 是一个初始化式
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      在同一个声明中可以对任意数量的变量进行初始化。 int
                      height = 8，length = 12， width = 10；
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      2中的每个变量都有值，而接下来只有width有值：
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          只有width初始化：int height，length， width =
                          10；
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  用赋值的方法给变量赋初始值。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="读入输入">
        <title>5. 读入输入</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              scanf：
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  printf和scanf的f含义相同都是<quote>格式化</quote>的意思。
                </para>
              </listitem>
              <listitem>
                <para>
                  printf和scanf都需要使用<emphasis role="strong">格式串</emphasis>来制定输入或输出的形式
                </para>
              </listitem>
              <listitem>
                <para>
                  之所以这样是因为输入和输入都需要知道数据的类型。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="定义常量的名字">
        <title>6. 定义常量的名字</title>
        <blockquote>
          <para>
            当程序含有常量时，建议给这些常量命名。
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              可以使用宏定义来给常量命名：
              <literal>#define INCHES_PER_POUND 16</literal>
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="标识符">
        <title>7. 标识符</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              一般标识符遵循只是用小写的规范，必要还可以插入下划线或驼峰命名
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="c89关键字">
        <title>6. C89关键字</title>
        <para>
        </para>
      </section>
      <section xml:id="有关数据模子的关键字voidcharshortintlongfloatdoublesizeof">
        <title>1.
        有关数据<quote>模子</quote>的关键字：void、char、short、int、long、float、double、sizeof；</title>
        <para>
        </para>
      </section>
      <section xml:id="有关数据符号的关键字signedunsigned">
        <title>2. 有关数据符号的关键字：signed、unsigned；</title>
        <para>
        </para>
      </section>
      <section xml:id="构造类型structunionenumtypedef">
        <title>3. 构造类型：struct、union、enum、typedef；</title>
        <para>
        </para>
      </section>
      <section xml:id="有关存储与生命周期的类型autostaticexternregisterconstvolatile">
        <title>4.
        有关存储与生命周期的类型：auto、static、extern、register、const、volatile；</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              register
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  说明：
                  这个关键字请求编译器尽可能的将变量存放在CPU内部的寄存器中，而不是通过内存寻址访问以提高效率（是尽可能，不是绝对）。
                </para>
              </listitem>
              <listitem>
                <para>
                  解释：寄存器其实就是一块一块小的存储空间，只不过其存储速度比内存快得多，但是价格昂贵。
                </para>
              </listitem>
              <listitem>
                <para>
                  注意：
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      register变量必须是一个单个的值，并且其长度必须小于或等于整形的长度。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      register变量可能不存在内存中，所以不能用取地址运算符<quote>&amp;</quote>来获取register变量的地址。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              static；详见mybase。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  说明：声明静态变量。
                </para>
              </listitem>
              <listitem>
                <para>
                  作用：
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      修饰变量：static可以修饰局部变量和全局变量，它们都存放在内部的静态区中。
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          静态全局变量：作用域仅限于变量被定义的文件中，其他文件即使使用extern声明也不能使用它。准确的说：作用域是从定义之处开始到文件结束。在定义之处前面的那些代码行也不能使用它，想要使用就得在前面再加extern***。
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          静态局部变量：作用域仅限于该函数里，该文件中的其他函数也用不了。虽然局部变量的生命周期随着函数的结束而终止，但是因为被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值也不会被销毁，函数下次使用时仍然能用到这个值。
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  注意，static的生命只执行一次，下次就从内存中找变量的值。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              符号关键字： unsigned和signed
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  说明：最高位如果是1，表明这个数是负数，其值为除最高位以外的剩余位的值加上<quote>-</quote>号；最高位如果是0，表明这个数是正数，其值为除最高位以外的剩余位的值。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              const
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  说明：const是constant的缩写，表示恒古不变。被const修饰的变量称为常变量，准确来说应该是只读的变量
                </para>
              </listitem>
              <listitem>
                <para>
                  作用：
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      修饰只读变量：定义const只读变量，具有不可变性。
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          const int Max = 100；
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          释：<font color=green>const修饰的只读变量必须在定义的同时初始化，因为定义后就不能再被改变了。</font>
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          int Array[Max];
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          释：这样编译时会报错，<font color=green>数组下标只能是常量</font>，即使常变量也不可以，但是宏常数可以。
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                  <listitem>
                    <para>
                      修饰数组
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      修饰指针
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      case 后面的数字不可以用const
                      修饰，因为case后面只能是常量、字符型常量和常量表达式
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              volatile
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  说明：volatile是易变、不稳定的意思。
                </para>
              </listitem>
              <listitem>
                <para>
                  作用：用volatile修饰的变量可以被某些编译器未知的因素更改，即更新数据，未知的因素如操作系统、硬件或者其他线程等。
                </para>
              </listitem>
              <listitem>
                <para>
                  例子1：
                </para>
                <programlisting>
 int i = 10;
 int j = i;//1）语句
 int k = i;//2）语句
</programlisting>
                <para>
                  分析：编译时编译器认为i的值没有发生变化，所以在1）语句时从内存中取出i的值赋给j后并没有被丢掉，在2）语句时继续用这个值给k赋值，而不生成汇编代码重新从内存里取出i的值。
                </para>
              </listitem>
              <listitem>
                <para>
                  例子2：
                </para>
                <programlisting>
  volatlie int i = 10;
  int j = i;
  int k = i;
</programlisting>
                <para>
                  分析：例2与例1不同的是，volatile关键字告诉编译器，i的值随时可能发生变化，则每次用i，编译器都会生成汇编代码从内存中取i的值。
                </para>
              </listitem>
              <listitem>
                <para>
                  问题：const volatile int i =
                  10;这行代码有没有问题？如果没有，那么i到底是什么属性？
                </para>
              </listitem>
              <listitem>
                <para>
                  答：没有问题。因为const表示常量语义，被const修饰的对象在所在的作用域里无法进行修改；volatile表示易变的，即在运行期对象可能在当前程序上下文的控制流以外被修改。发生易变的情况，如：在多线程中。被其他线程修改；对象所在的存储器可能被多个硬件设备随机修改等情况。例如，只读的状态寄存器，它是volatile属性，因为它可能被意外的修改。但是，同时它也具有const属性，因为它修饰的内容只能被读而不能被写。可知：它们控制的范围不同，被const修饰的对象在程序本身内不能修改，而被volatile修饰的对象可能在本程序外被修改。所以，const和volatile一起使用没有问题。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="有关语句的类型ifelseforwhiledoswitchcasefaultgotobreakcontinuereturn">
        <title>5.
        有关语句的类型：if、else、for、while、do、switch、case、fault、goto、break、continue、return</title>
        <para>
        </para>
      </section>
      <section xml:id="c99关键字">
        <title>7. C99关键字</title>
        <para>
        </para>
      </section>
      <section xml:id="bool-bool-类型变量等价于unsigned-char只有0和1">
        <title>1. _Bool &gt; bool 类型变量，等价于unsigned
        char，只有0和1</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              头文件：&lt;stdbool.h&gt;
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="complex-对于c99-标准定义-存在-float-_complex-double-_complex-long-double-_complex-复数类型.">
        <title>2. _Complex &gt; 对于C99 标准定义, 存在 float _Complex,
        double _Complex, long double _Complex 复数类型.</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              头文件: &lt;complex.h&gt;
            </para>
          </listitem>
          <listitem>
            <para>
              其实在复数类型中，gcc标准实现
            </para>
            <para>
              <literal>#define complex _Complex</literal>
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="imaginary-虚数类型_complex复数类型的虚部关键字系统保留我们无法使用">
        <title>3. _Imaginary &gt;
        虚数类型,_Complex复数类型的虚部。关键字系统保留，我们无法使用。</title>
        <para>
        </para>
      </section>
      <section xml:id="inline">
        <title>4. inline</title>
        <blockquote>
          <para>
            内联函数,从C++中引入的概念. 就是将小函数直接嵌入到代码中.
            C的代码损耗在于函数的进出栈. 要是可以推荐用内联函数替代宏.
            宏能不用就不用. 函数声明的时候不要加inline 需要加extern,
            定义的时候需要加inline
          </para>
        </blockquote>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              例子
            </para>
            <programlisting>
 extern cjson_t cjson_newtstr(tstr_t str);

 inline cjson_t 
 cjson_newtstr(tstr_t str) {
     str-&gt;len = _cjson_mini(str-&gt;str);
     return _cjson_parse(str-&gt;str);
 }

 // 还有就是和static 一起使用
 static inline int _sconf_acmp(tstr_t tstr, struct sconf * rnode) {
     return strcmp(tstr-&gt;str, rnode-&gt;key);
 }
</programlisting>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="restrict">
        <title>5. restrict</title>
        <blockquote>
          <para>
            这是很装逼的关键字用于编译器优化.
            关键字restrict只用于限定指针；该关键字用于告知编译器，
            所有修改该指针所指向内容的操作全部都是基于(base
            on)该指针的，即不存在其它进行修改操作的途径；
            这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              演示
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  摘自GCC 的 string.h中
                </para>
                <programlisting>
 extern void *mempcpy (void *__restrict __dest,
                       const void *__restrict __src, size_t __n)
      __THROW __nonnull ((1, 2));
</programlisting>
              </listitem>
              <listitem>
                <para>
                  正式用法
                </para>
                <programlisting>
 // 简单演示用法, GCC 和 VS 都是 __restrict 推荐加在 * 后面
 static void _strlove(char * __restrict dest) {
     *dest = '\0';
 }
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="c11关键字">
        <title>8. C11关键字</title>
        <para>
        </para>
      </section>
      <section xml:id="alignas-1.-解释-内存对齐的操作符需要和_alignof配合使用-2.-演示">
        <title>1. _Alignas 1. 解释:
        内存对齐的操作符，需要和_Alignof配合使用。 2. 演示：</title>
        <programlisting>
    #ifndef __cplusplus

    #define alignas _Alignas
    #define alignof _Alignof

    #define __alignas_is_defined 1
    #define __alignof_is_defined 1

    #endif

    #include &lt;stdio.h&gt;
    #include &lt;stdalign.h&gt;

    struct per {
        int age;
        double secl;
        char sex;
    };

    int main(int argc, char * argv[]) {
        char c[100];
        alignas(struct per) struct per * per = (struct per *)&amp;c;
        printf(&quot;per = %p, c = %p.\n&quot;, per, c); 

        return 0;
    }
</programlisting>
      </section>
      <section xml:id="alignof-1.-解释-得到类型和变量的对齐方式.-2.-演示">
        <title>2. _Alignof 1. 解释： 得到类型和变量的对齐方式. 2.
        演示：</title>
        <programlisting>
printf(&quot;alignof(struct per) = %zd.\n&quot;, alignof(struct per));
</programlisting>
      </section>
      <section xml:id="atomic-1.-解释-原子操作-原子锁.-gcc-很早就支持.-详细用法可以参照-cas-httpssanwen8.cnp18dzqie.html讲的可以-2.-演示">
        <title>3. _Atomic 1. 解释: 　　原子操作, 原子锁. gcc 很早就支持.
        详细用法可以参照 CAS https://sanwen8.cn/p/18dZQie.html讲的可以
        2. 演示：</title>
        <programlisting>
    #include &lt;stdio.h&gt;
    #include &lt;stdatomic.h&gt;

    int main(int argc, char * argv[]) {
    
        _Atomic int hoge = ATOMIC_VAR_INIT(100);
        int piyo = atomic_load(&amp;hoge);  
        printf(&quot;piyo = %d.\n&quot;, piyo);
        piyo += 2;
        atomic_store(&amp;hoge, piyo);
        printf(&quot;hoge = %d.\n&quot;, hoge);

        return 0;
    }
</programlisting>
      </section>
      <section xml:id="generic-1.-解释c的泛函机制高级函数宏-2.-演示">
        <title>4. _Generic 1. 解释：C的泛函机制，高级函数宏 2.
        演示：</title>
        <programlisting>
    #include &lt;math.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    #define ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)

    //
    // 测试 C11 语法
    //
    int main(int argc, char * argv[]) {
        
            int a = 1, b = 2, c = 3;
        
            _Generic(a + 0.1f, int:b, float:c, default:a)++;
            printf(&quot;a = %d, b = %d, c = %d\n&quot;, a, b, c); 

            printf(&quot;int abs: %d\n&quot;, ABS(-12));
            printf(&quot;float abs: %f\n&quot;, ABS(-12.04f));
            printf(&quot;double abs: %f\n&quot;, ABS(-13.09876));

            return EXIT_SUCCESS;
    }
</programlisting>
      </section>
      <section xml:id="noreturn-1.-解释-1.-修饰函数绝对不会有返回值.-_noreturn-声明的函数不会返回.-引入此新的函数修饰符有两个目的-1.-消除编译器对没有-return的函数的警告.-2.-允许某种只针对不返回函数的优化.">
        <title>5. _Noreturn 1. 解释: 　　1. 修饰函数,绝对不会有返回值.
        _Noreturn 声明的函数不会返回. 引入此新的函数修饰符有两个目的: 1.
        消除编译器对没有 return的函数的警告. 2.
        允许某种只针对不返回函数的优化.</title>
        <orderedlist numeration="arabic">
          <listitem override="2">
            <para>
              演示:
            </para>
            <programlisting>
 _Noreturn void suicide(void) {
     abort(); // Actually, abort is _Noreturn as well
 }
</programlisting>
          </listitem>
          <listitem>
            <para>
              再扯一点, GCC中等同于
              <emphasis role="strong">attribute</emphasis>((<emphasis role="strong">noreturn</emphasis>)),
              在VC中相似功能是 __declspec(noreturn).
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  它不是说函数没有返回值，而是说一旦你调了这个函数，它永远不会返回。一些函数是永远不会返回的，
                </para>
              </listitem>
              <listitem>
                <para>
                  比如 abort或者 exit之类，调用它们就意味着结束程序.
                  所以 warning就显得没有必要.
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="static_assert-1.-解释-编译器期间断言-当-if-error-搞完毕预编译之后-编译器断言.-assert是运行时断言.用的时候看具体的需求.-2.-演示">
        <title>6. _Static_assert 1. 解释: 编译器期间断言, 当 #if #error
        搞完毕(预编译)之后, 编译器断言.
        assert是运行时断言.用的时候看具体的需求. 2. 演示:</title>
        <programlisting>
    _Static_assert(__STDC_VERSION__ &gt;= 201112L, &quot;C11 support required&quot;);
    // Guess I don't really need _Static_assert to tell me this :-(
</programlisting>
      </section>
      <section xml:id="thread_local-1.-解释_thread_local是新的存储类修饰符-限定了变量不能在多线程之间共享-2.-演示">
        <title>7. _Thread_local 1.
        解释：_Thread_local是新的存储类修饰符,
        限定了变量不能在多线程之间共享。 2. 演示:</title>
        <programlisting>
    _Thread_local static int i;
    // Thread local isn't local!
    语义上就是线程的私有变量.
</programlisting>
      </section>
      <section xml:id="程序结构">
        <title>9. 程序结构</title>
        <para>
        </para>
      </section>
      <section xml:id="局部变量">
        <title>1. 局部变量</title>
        <blockquote>
          <para>
            把在函数体内声明的变量称为该函数的局部变量。
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              性质
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  自动存储期限。 &gt;
                  变量的存储期限是在变量存储单元存在期内程序执行的部分。
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      局部变量的存储单元是在包含该变量的函数被调用时<quote>自动</quote>分配的，函数返回时收回分配。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  块作用域 &gt;
                  变量的作用域是可以应用该变量的程序文本的部分，从声明变量到所在的函数体的末尾。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              静态局部变量 &gt;
              在局部变量声明中放置单词static可以使变量具有静态存储期限而不再是自动存储期限。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="外部变量">
        <title>2. 外部变量</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              性质
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  静态存储期限
                </para>
              </listitem>
              <listitem>
                <para>
                  文件作用域
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="程序块">
        <title>3. 程序块</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              声明： [程序块] {多条声明 多条语句};
            </para>
          </listitem>
          <listitem>
            <para>
              例如
            </para>
            <programlisting>
 if (i &gt; j) {
     int tmep = i;
     i = j;
     j = tmep;
 }
</programlisting>
          </listitem>
          <listitem>
            <para>
              默认情况下，声明在程序块中的变量的存储期限是自动的：进入程序块时，为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，不能再程序块外引用。
            </para>
          </listitem>
          <listitem>
            <para>
              注意这是C语言里特有的程序块，大括号括起。python里没有这种结构。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="作用域">
        <title>4. 作用域</title>
        <para>
        </para>
      </section>
    </section>
  </section>
  <section xml:id="二.高级数据结构">
    <title>二.高级数据结构</title>
    <section xml:id="数组">
      <title>1. 数组</title>
      <blockquote>
        <para>
          数组是含有多个数据值的数据结构，并且每个数据结构具有相同的数据类型。
        </para>
      </blockquote>
      <orderedlist numeration="arabic" spacing="compact">
        <listitem>
          <para>
            其他变量基本变量都是<emphasis role="strong">标量</emphasis>，标量具有保存单一数据项的能力。
          </para>
        </listitem>
        <listitem>
          <para>
            C语言一共有两种聚合类型：数组和结构
          </para>
        </listitem>
      </orderedlist>
      <section xml:id="一维数组">
        <title>1. 一维数组</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              声明：需要指明数组元素的类型和数量：<literal>int a[10];</literal>
            </para>
          </listitem>
          <listitem>
            <para>
              数组的元素可以是任意类型，数组的长度可以用任何(整数)常量表达式指定，因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：
            </para>
            <programlisting>
 #define N 100
 。。。
 int a[N];
</programlisting>
          </listitem>
          <listitem>
            <para>
              数组初始化
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  数组初始化式：
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      初始化式比数组短，数组剩余元素为0： int a[10] =
                      {1, 3, 4}
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      利用2可以将数组初始化为一个值：int a[10] = {0}
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      初始化式完全为空是非法的。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      int a[] = {1, 2, 3, 4,
                      5}编译器会利用初始化式的长度来确定数组的大小。<emphasis role="strong">数组仍然有固定数量的元素，这和明确指定长度效果一样</emphasis>
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  指定初始化式
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      使用场景：数组中只有相对较少的元素需要进行显示的初始化，其他元素进行默认赋值。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      C99中的 指定初始化可以解决这一问题
                    </para>
                    <programlisting>
 int a[15] = {[2] = 29, [9] = 7, [14] = 48};
 括号里的数字成为指示符
 指示符必须是整型常量表达式
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      指定初始化式还有一个优点：赋值的顺序不再是一个问题。
                    </para>
                    <programlisting>
 int a[15] = {[14] = 29, [9] = 7, [1] = 48};
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      初始化式可以同时使用老方法和新方法
                    </para>
                    <programlisting>
 int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6};
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              对数组使用sizeof
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  确定数组的大小： sizeof(a)
                </para>
              </listitem>
              <listitem>
                <para>
                  确定数组元素的大小： sizeof(a[0])
                </para>
              </listitem>
              <listitem>
                <para>
                  确定数组长度： sizeof(a) / siezeof(a[0])
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="多维数组">
        <title>2. 多维数组</title>
        <blockquote>
          <para>
            C语言中的多维数组扮演的角色相对较弱，这主要是因为C语言Wie存储数据提供了更加灵活的方法：指针数组。
          </para>
        </blockquote>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              多维数组初始化
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  嵌套一维数组初始化式
                </para>
                <programlisting>
 int m[5][9] = {{1, 1,1,……},{0,1, 2, 2,……},……}

 每个内部初始化提供了矩阵中的一行的值
</programlisting>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      没有填满整个数组的话，省略的部分初始化为0
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      可以省略内层的大括号，编译器一旦发现数组足以填满一行，它就开始填充下一行。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      C99指定初始化式也有用：
                    </para>
                    <programlisting>
 double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
</programlisting>
                    <blockquote>
                      <para>
                        无论一维数组还是多维数组，都可以在声明最开始处加上单词const而成为<quote>常量</quote>
                      </para>
                    </blockquote>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              程序不应该对声明为const的数组进行修改。编译器能够检测到直接修改某个元素的意图。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="变长数组">
        <title>4. 变长数组</title>
        <blockquote>
          <para>
            数组变量的长度必须用常量表达式进行定义，但是在C99中，有时候也可以使用非常量表达式。
            声明变长数组的时候可以用变量表示数组里的存储区个数，如果程序多次运行则每次运行的时候变长数组里包含的存储区个数都可能不同。但是某次程序运行中变长数组里的存储区个数不变。
          </para>
        </blockquote>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              <emphasis role="strong">变长数组不可以初始化，编译会出错，如果对变长数组赋值只能使用循环语句进行循环赋值</emphasis>
            </para>
          </listitem>
          <listitem>
            <para>
              eg
            </para>
            <programlisting>
 #include &lt;stdio.h&gt;
 int main(){
     int num = 0;
     printf(&quot;请输入一个整数：&quot;);
         scanf(&quot;%d&quot;, &amp;num);
         int arr[num];
         printf(&quot;sizeof(arr) = %d\n&quot;, sizeof(arr)); return 0;
     }
</programlisting>
          </listitem>
          <listitem>
            <para>
              问答
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  如果试图用赋值运算符把一个数组复制到另一个数组中，编译器将给出出错消息，哪里错了？
                </para>
              </listitem>
              <listitem>
                <para>
                  答：这个需要用到C语言里的数组和指针之间的特殊关系，后面会解答。
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      把一个数组复制到另一个数组最简单的实现方法是利用循环对数组元素逐个进行赋值。
                    </para>
                    <programlisting>
 for (i = 0; i &lt; N; i++)
     a[i] = b[i]
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      另一种可行的方法是使用来自&lt;string.h&gt;头文件的memcpy(意思是：内存复制).
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="结构联合枚举">
      <title>2. 结构、联合、枚举</title>
      <section xml:id="结构">
        <title>1. 结构</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              结构是可能具有不同类型的值(成员)的集合
            </para>
          </listitem>
          <listitem>
            <para>
              声明：
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  声明格式和其他C语言变量声明格式类似： struct {…}
                  part1, part2; struct {…} 指明了类型。
                </para>
                <programlisting>
 struct {
     int number;
     char name [NAME_LEN+1];
     int on_hand;
 } part1, part2;
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              初始化，也可以在声明的同时进行初始化，像数组一样，大括号括起来。初始化式中的值必须按照结构成员的顺序进行显示。用于结构初始化式的表达式必须是常量。不能用变量来初始化结构体。这一限制在C99中放宽了。
            </para>
            <programlisting>
 struct {
     int number;
     char name[NAME_LEN+1];
 } part1 = { 23, &quot;Disk driver&quot;},
   part2 = { 34, &quot;Prinnter cable&quot;};
</programlisting>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  初始化式中的成员可以少于它所初始化的结构，剩余补零或空字符。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              指定初始化
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  类似于数组的指定初始化式，但不是通过下标而是名字赋值。
                </para>
                <programlisting>
 {.number = 345, .name = &quot;Disk driver&quot;, .on_hand = 10}
</programlisting>
              </listitem>
              <listitem>
                <para>
                  将点号和成员名称的组成称为<emphasis role="strong">指示符</emphasis>，
                  .的优先级类似++，所以几乎高于所有的运算符
                </para>
              </listitem>
              <listitem>
                <para>
                  指定初始化式可以不按照结构中定义的顺序来初始化。
                </para>
              </listitem>
              <listitem>
                <para>
                  指定初始化式和初始化混用：
                </para>
                <programlisting>
 {.number = 34, &quot;Disk driver&quot;, .on_hand = 34}
</programlisting>
              </listitem>
              <listitem>
                <para>
                  值<quote>Disk driver</quote>
                  的前面没有指示符，所以编译器认为它是初始化结构中位于number之后的成员
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              操作
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  结构体成员是左值
                </para>
              </listitem>
              <listitem>
                <para>
                  结构体中所有成员都可以使用 =
                  来进行赋值，数组本身不可以复制，但是结构体中的数组可以复制。
                </para>
                <programlisting>
 part1 = part2;
</programlisting>
              </listitem>
              <listitem>
                <para>
                  = 运算符仅仅用于类型兼容的结构。
                </para>
              </listitem>
              <listitem>
                <para>
                  除了赋值运算，C语言没有提供其他用于整个结构的操作
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=red>不能使用 == 和 !=
                  来判断两个结构是相等还是不等</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="结构类型">
        <title>2. 结构类型</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              由以上可知，声明一个struct时，需要 struct {…}
              变量名，这样会导致程序膨胀，并且如果多个地方定义的话可能难以确保声明一致，还有就是多个struct
              {…} 变量名，它们不具有兼容类型。
            </para>
          </listitem>
          <listitem>
            <para>
              所以需要定义表示结构的<emphasis role="strong">类型</emphasis>(而不是特定的结构变量)的名字
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  结构标记的声明 &gt; 使用于标识某种特定结构的名字。
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      例子
                    </para>
                    <programlisting>
 struct part {
     int number;
     char name[NAME_LEN+1];
     int on_hand;
 };
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      注意：右花括号后的分号必不可少，它表示声明结束。
                      struct {…} 是一个类型;struct 标识符 {…}
                      是一个声明语句，声明一个struct part
                      的类型，所以需要加分号。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      创建了标记part，就可以用它来声明变量：注意，类型是struct
                      part，而不是part。
                    </para>
                    <programlisting>
 struct part part1, part2;
 绝对不能漏写struct，part并不是类型名
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  结构类型的定义 &gt;
                  除了声明的结构标记，还可以使用typedef
                  来定义真实的类型名
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      例子
                    </para>
                    <programlisting>
 typedef struct {
     int number;
     ...
 } Part;

 Part part1, part2;
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      这时一个typedef
                      语句，要加分号，并且Part必须出现在定义的末尾。这个类型就是Part，而不是上面的struct
                      part。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  用途 &gt;
                  通常既可以选择声明标识符也可以用typedef，但是结构用于链表时强制使用声明结构标记。
                </para>
              </listitem>
              <listitem>
                <para>
                  结构作为参数和返回值
                </para>
                <orderedlist numeration="arabic">
                  <listitem override="0">
                    <para>
                      C函数调用，实参都是值传递，指针也是值传递，只不过复制的是指针中保存的地址，使得新的指针还是指向原来的变量。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      结构作为参数和返回值，都是值传递，需要复制结构体，为了防止系统复制开销，可以使用指向结构的指针来避免复制。有些结构必须保持唯一，指针也是一个办法。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      结构体可以相互赋值的。
                    </para>
                    <programlisting>
 void f(struct part part1){
     struct part part2 = part1;
     ...
 }
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  复合字面量
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      数组那一节中，复合字面量别用于创建没有名字的数组，这样做的目的通常是将数组作为参数传递给函数。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      复合字面量同样可以用于<quote>实时</quote>创建一个结构，而不需要先将其存储在变量中，生成的结构可以像参数一样传递，可以被函数返回，也可以赋值给变量
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      例子
                    </para>
                    <programlisting>
 print_part((struct part) {234, &quot;Disk driver&quot;, 10});
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  结构数组
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      结构数组的初始化：和多维数组的初始化方法非常相似，每个结构都拥有自己的花括号括起来的初始化式，数组的初始化式简单的在结构初始化式外围括上另外一对花括号。
                    </para>
                    <programlisting>
 struct dialing_code {
     char *country;
     int code;
 };

 const struct dialing_code country_codes[] = 
 { {&quot;Argentina&quot;, 34}, {&quot;Bangladesh&quot;, 880} };
</programlisting>
                  </listitem>
                  <listitem>
                    <para>
                      C99的指定初始化式允许每一项具有多个指示符。
                    </para>
                    <programlisting>
 struct part inven[100] = { [0].number = 234, [0].on_hand = 10, [0].name[0] = '\0' };
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="联合">
        <title>3. 联合</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              概述
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  联合和结构类似，不同之处在于联合的成员共享同一存储空间，这样的结果是，联合可以每次存储一个成员，但无法同时存储全部成员
                </para>
              </listitem>
              <listitem>
                <para>
                  联合也是由一个或多个成员构成的，而这些成员可以具有不同的类型。
                </para>
              </listitem>
              <listitem>
                <para>
                  编译器只为联合中最大的成员分配足够的内存空间，联合的成员在这个空间内彼此覆盖。
                </para>
              </listitem>
              <listitem>
                <para>
                  这样的结果是给一个成员赋值，也会改变其他成员的值。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              因为编译器把联合的成员重叠存储，所以改变一个成员会使之前存储在任何其他成员中的值发生改变。其他成员会输入无意义的字符。
            </para>
          </listitem>
          <listitem>
            <para>
              联合的性质和结构几乎一样
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  区别是结构中的成员在内存中有各自的地址空间，而联合的成员存储在同一内存地址中。
                </para>
              </listitem>
              <listitem>
                <para>
                  可以用生命结构标记和类型的方法来声明联合的标记和类型
                </para>
              </listitem>
              <listitem>
                <para>
                  相结构一样，联合可以使用运算符 =
                  进行复制，也可以传递给函数，还可以有函数返回。
                </para>
              </listitem>
              <listitem>
                <para>
                  联合的初始化方式也和结构的初始化很类似，但是，只有联合的<emphasis role="strong">第一个成员</emphasis>可以获得初始值。
                </para>
                <programlisting>
 union {
     int i;
     double d;
 } u = {0};
</programlisting>
              </listitem>
              <listitem>
                <para>
                  注意或括号是必须的,花括号里的表达式必须是常量。(C99中的规则稍有不同)
                </para>
              </listitem>
              <listitem>
                <para>
                  指定初始化式也可以用在联合中，指定初始化式允许我们指定需要对联合中的哪个成员进行初始化。
                </para>
                <programlisting>
 union {
     int i;
     double d;
 } u = {.d = 10.0};

 只能初始化一个成员，但不一定是第一个。
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              用途
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  用联合来节省空间
                </para>
              </listitem>
              <listitem>
                <para>
                  用联合来构造混合的数据结构
                </para>
                <orderedlist numeration="arabic">
                  <listitem>
                    <para>
                      假设需要数组的元素是int值和double值的混合，因为数组的元素必须是相同的类型，所以好像不可能，但是利用union就相对容易了
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      例子
                    </para>
                    <programlisting>
 typedef union {
     int i;
     double d;
 } Number;

 Number number_array[100];
</programlisting>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              为联合添加<quote>标记字段</quote> &gt;
              联合不知道改变的是哪个成员
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  把一个联合嵌入一个结构中，且此结构还含有另一个成员：<quote>标记字段</quote>或者<quote>判别式</quote>，它是用来提示当前存储在联合中的内容的。
                </para>
                <programlisting>
 #define INT_KIND 0
 #define DOUBLE_KIND 1

 typedef struct {
     int kind;
     union {
         int i;
         double d;
     } u;
 } Number;
</programlisting>
              </listitem>
              <listitem>
                <para>
                  每次对联合的成员进行赋值，都由程序负责改变标记字段的内容。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="枚举">
        <title>3. 枚举</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              枚举是一种整数类型，它的值由程序员来命名
            </para>
          </listitem>
          <listitem>
            <para>
              枚举类型是一种值有程序员你列出的类型，而且程序员必须为每个值命名(枚举常量)
            </para>
            <programlisting>
 enum {CLUBS, DIAMONDS, HEARTS} s1, s2;
</programlisting>
          </listitem>
          <listitem>
            <para>
              枚举常量的名字必须不同于作用域内声明的其他标识符。
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
  <section xml:id="三.-字符串处理替换查找截断">
    <title>三. 字符串处理：替换，查找、截断</title>
    <section xml:id="字符基础">
      <title>1. 字符基础</title>
      <section xml:id="字符字面量">
        <title>1. 字符字面量</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              字符串字面量是作为数组来存储的，所以编译器会把它看做是char
              *类型的指针。
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=red>注意，字符串字面量相当于是char *
              类型的，所以通常情况下在C语言允许使用char
              *指针的地方使用字符串字面量</font>
            </para>
            <programlisting>
 char *p;
 p = &quot;abc&quot;
</programlisting>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  <font color=red>注意，这个赋值操作不是赋值<quote>abc</quote>中的字符，而是使p指向字符串的第一个字符</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              C语言允许对指针取下标，因此可以对字符串字面量取下标。
            </para>
            <programlisting>
 char ch;
 ch = &quot;abc&quot;[1];
</programlisting>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  这个特性并不常用，但有时也有方便，eg如下，将0-15的数转换为等价的十六进制字符形式。
                </para>
                <programlisting>
 char digit_to_hex_char(int digit){
     return &quot;0123456789ABCDEF&quot;[digit];
 }
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              试图改变字符串字面量会导致未定义的行为
            </para>
          </listitem>
          <listitem>
            <para>
              字符串字面量和字符常量是不同的。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  字符串字面量<quote>a</quote>是用指针来表示的，这个指针指向存放字符<quote>a</quote>(后面紧跟空字符)的内存单元。
                </para>
              </listitem>
              <listitem>
                <para>
                  字符常量’a’是用整数(字符集的数值码)来表示的
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="字符串变量">
        <title>2. 字符串变量</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。字符串的所有库函数也都是默认字符数组以空字符结尾。
            </para>
          </listitem>
          <listitem>
            <para>
              如果声明的字符数组长度小于或等于字符串的长度，会使得字符数组末尾没有空字符，会导致不可知的错误。
            </para>
          </listitem>
          <listitem>
            <para>
              字符数组与字符指针
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  相似声明： char date[] = <quote>abce 14</quote>; char
                  *date = <quote>abce 14</quote>;
                </para>
              </listitem>
              <listitem>
                <para>
                  不能错误的认为以上两种date可以互换，它们有很大差异：
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。而声明为指针时，date指向字符串字面值，字符串字面量是不可以修改的。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      在声明为数组是，date是数组名，date本身是不可以修改的。在声明为指针时，date是变量，这个变量是可以在程序执行期间指向其他字符串的。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      如果想要可以修改字符串，那么就要建立字符数组来存储字符串。生命指针变量就不够。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      在使用指针p作为字符串之前，必须把p指向字符数组，使用未初始化的指针当做字符串会引起很严重的后果，不知道指针指向哪里。
                    </para>
                    <orderedlist numeration="arabic">
                      <listitem>
                        <para>
                          把p指向已经存在的字符串变量
                        </para>
                        <programlisting>
 char str[STR_LEN + 1], *p;
 p = str;
</programlisting>
                      </listitem>
                      <listitem>
                        <para>
                          让p指向一个动态分配的字符串：
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="字符串的库函数">
        <title>3. 字符串的库函数</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              <font color=red>C语言中把字符串当做数组来处理，因此对字符串的限制方式和对数组的一样，特别是，它们都不能用C语言的云算法进行复制和比较操作</font>
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  直接复制和比较字符串会失败：
                </para>
                <programlisting>
 char str1[10], str2[10];
 str1 = &quot;abc&quot;;  wrong
 str2 = str1;   wrong
</programlisting>
              </listitem>
              <listitem>
                <para>
                  把数组名用作=的左操作数时非法的，但是=初始化字符数组是合法的：
                </para>
                <programlisting>
 char str[10] = &quot;abc&quot;;  right
</programlisting>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      因为声明数组时，如果不初始化，编译器会自动填上合适的字符，例如int是0，char是空字符。所以声明时已经赋值了，在用等号就是赋值操作，不可以直接对数组复制赋值。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  试图使用关系运算符或判等运算符来比较字符串是合法的，但是不会产生预期的结果：
                </para>
                <programlisting>
 if (str1 == str2) ...   wrong
</programlisting>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      这条语句把str1
                      和str2作为指针来比较，而不是比较两个数组的内容，因为str1和str2有不同的地址，所以表达式str1
                      == str2 的值一定为0.
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              &lt;string.h&gt;
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  <font color=red>注意，此头文件中的字符串类型声明为char
                  <emphasis>，所以字符指针、数组、字面量都可以，但是字面量不可改变，相当于const
                  char
                  </emphasis>，所以字面量不能用作可变形参的实参</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  strcpy: char <emphasis>strcpy(char </emphasis>s1,
                  const char *s2);
                </para>
              </listitem>
              <listitem>
                <para>
                  strncpy： strncpy(str1, str2, sizeof(str1));
                  会检查复制的个数，但如果str2的字符串长度大于str1数组长度，会导致str1没有终止的空字符。一下是安全用法
                </para>
                <programlisting>
 strncpy(str1,  str2, sizeof(str1) - 1);
 str1[sizeof(str1)-1] = '\0';
</programlisting>
              </listitem>
              <listitem>
                <para>
                  strlen: size_t strlen(const char *s);
                </para>
              </listitem>
              <listitem>
                <para>
                  strcat: char <emphasis>strcat(char </emphasis>s1,
                  const char *2);
                </para>
              </listitem>
              <listitem>
                <para>
                  strncat: 与strncpy类似，需要计算一下空字符的位置。
                </para>
              </listitem>
              <listitem>
                <para>
                  strcmp: 比较函数：int strcmp(const char <emphasis>s1,
                  const char </emphasis>s2);
                  <font color=green>指针和数组不可以利用运算符比较，可以利用这个函数来比较</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              惯用法
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  惯用法
                </para>
                <programlisting>
 while (*s)
     s++;

 while (*s++)
     ;

 while (*p++ = *s++)
     ;
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              字符串数组
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  二维数组，可以省略行数，这个可以从初始化式求出，但是C语言要求指明列数。
                </para>
                <programlisting>
 char planets[][8] = {&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;}
</programlisting>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      这种二维数组中，每一行都有同样的长度，但是列的长度是所有字符串中最长的，这样没有填满二维数组导致浪费空间。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
              <listitem>
                <para>
                  一维指针数组
                </para>
                <programlisting>
 char *panets[] = {&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;};        
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="regex">
      <title>2. Regex</title>
      <para>
      </para>
    </section>
    <section xml:id="parser">
      <title>3. Parser</title>
      <para>
      </para>
    </section>
    <section xml:id="字符编码">
      <title><font color=green>4. 字符编码</font></title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="四.-基本面向对象或函数式编程的特征">
    <title>四. 基本面向对象或函数式编程的特征</title>
    <section xml:id="继承">
      <title>1. 继承</title>
      <para>
      </para>
    </section>
    <section xml:id="多态">
      <title>2. 多态</title>
      <para>
      </para>
    </section>
    <section xml:id="lambda-函数">
      <title>3. Lambda 函数</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="五.-调试tdd技能">
    <title>五. 调试：TDD技能</title>
    <section xml:id="异常">
      <title>1. 异常</title>
      <para>
      </para>
    </section>
    <section xml:id="错误处理">
      <title>2. 错误处理</title>
      <para>
      </para>
    </section>
    <section xml:id="断言">
      <title>3. 断言</title>
      <para>
      </para>
    </section>
    <section xml:id="日志">
      <title>4. 日志</title>
      <para>
      </para>
    </section>
    <section xml:id="调试支持">
      <title>5. 调试支持</title>
      <para>
      </para>
    </section>
    <section xml:id="单元测试">
      <title><font color=green>6. 单元测试</font></title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="六.-运行时">
    <title><font color=green>六. 运行时</font></title>
    <section xml:id="程序代码和可执行代码的组织机制">
      <title>1. 程序代码和可执行代码的组织机制</title>
      <para>
      </para>
    </section>
    <section xml:id="运行时模块加载">
      <title>2. 运行时模块加载</title>
      <para>
      </para>
    </section>
    <section xml:id="符号查找机制">
      <title>3. 符号查找机制</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="七.-流">
    <title>七. 流</title>
    <section xml:id="基本输入输出">
      <title>1. 基本输入输出</title>
      <para>
      </para>
    </section>
    <section xml:id="文件处理">
      <title>2. 文件处理</title>
      <para>
      </para>
    </section>
    <section xml:id="输入输出流类的组织">
      <title>3. 输入输出流类的组织</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="八.-事件驱动">
    <title>八. 事件驱动</title>
    <section xml:id="callback-方法调用">
      <title>1. callback 方法调用</title>
      <para>
      </para>
    </section>
    <section xml:id="如何支持事件驱动编程模型">
      <title>2. 如何支持事件驱动编程模型</title>
      <section xml:id="net-的delegatejava的anonymous-inner-classjava-7的closurecox的tr1functionbind等各种语言都会在这里下足功夫">
        <title>1. .NET 的delegate，Java的anonymous inner class，Java
        7的closure，C++OX的tr1::function/bind……等各种语言都会在这里下足功夫。</title>
        <para>
        </para>
      </section>
    </section>
  </section>
  <section xml:id="九.-序列化和反序列化">
    <title>九. 序列化和反序列化</title>
    <section xml:id="缺省机制">
      <title>1. 缺省机制</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="十.-regex和xml处理问题可以跳过">
    <title>十. regex和XML处理问题，可以跳过</title>
    <para>
    </para>
  </section>
  <section xml:id="十一.-并发">
    <title>十一. 并发</title>
    <section xml:id="线程">
      <title>1. 线程</title>
      <para>
      </para>
    </section>
    <section xml:id="进程">
      <title>2. 进程</title>
      <para>
      </para>
    </section>
    <section xml:id="并发">
      <title>3. 并发</title>
      <para>
      </para>
    </section>
    <section xml:id="异步调用">
      <title>4. 异步调用</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="十二.-动态编程">
    <title>十二. <font color=green>动态编程</font></title>
    <section xml:id="反射">
      <title>1. 反射</title>
      <para>
      </para>
    </section>
    <section xml:id="元数据编程">
      <title>2. 元数据编程</title>
      <para>
      </para>
    </section>
    <section xml:id="数据和程序之间的相互转化机制">
      <title>3. 数据和程序之间的相互转化机制</title>
      <para>
      </para>
    </section>
    <section xml:id="运行时编译和执行的机制">
      <title>4. 运行时编译和执行的机制</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="十三.-语言常用的特色feature">
    <title>十三. 语言常用的特色feature</title>
    <section xml:id="指针">
      <title>1. 指针</title>
      <section xml:id="指针变量">
        <title>1. 指针变量</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              大多数现代计算机都讲内存分割为字节，每个字节8位。
            </para>
          </listitem>
          <listitem>
            <para>
              指针是变量的初始地址。
            </para>
          </listitem>
          <listitem>
            <para>
              指针的取值范围可能不同与整数的范围，所以一定不能用普通整数型变量来存储地址，但是可以用指针变量。
            </para>
          </listitem>
          <listitem>
            <para>
              指针就是地址，而指针变量就是存储地址的变量。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="指针变量的声明">
        <title>2. 指针变量的声明</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              int
              *p,说明p是指向int类型对象的指针变量。<font color=green>这里用术语对象来代替变量，是因为p可以指向不属于变量的内存区域。</font>
            </para>
          </listitem>
          <listitem>
            <para>
              每个指针变量只能指向一种特定类型(引用类型)的对象。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="取地址符">
        <title>3. 取地址符</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              取地址符: &amp;
            </para>
          </listitem>
          <listitem>
            <para>
              间接寻址: *
            </para>
          </listitem>
          <listitem>
            <para>
              如果p指向i，*p就是i的别名。
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=red>不要把间接寻址运算符用于未初始化的指针变量。如果指针变量p没有初始化，那么视图使用p的值会导致未定义的行为</font>
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  例如： int <emphasis>p; printf(<quote>%d</quote>,
                  </emphasis>p);
                </para>
              </listitem>
              <listitem>
                <para>
                  如果p恰好具有有效内存地址，那么会更改那个地址的数据
                </para>
              </listitem>
              <listitem>
                <para>
                  如果p指向的内存单元属于操作系统，那么很可能导致系统崩溃。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="指针赋值">
        <title>4. 指针赋值</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              <font color=green>C语言允许使用赋值运算符进行指针的复制，前提是两个指针具有相同的类型</font>
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  int i, j, <emphasis>p, </emphasis>q; p = &amp;i; q =
                  p;
                </para>
              </listitem>
              <listitem>
                <para>
                  q = p
                  是将p的内容(即i的地址)复制给q，效果是把q指向p所指向的地方。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="可以const来指明传递给函数的指针所指向的值不可改变">
        <title>5.
        可以const来指明传递给函数的指针所指向的值不可改变。</title>
        <programlisting>
void f(const int *p);
</programlisting>
      </section>
      <section xml:id="指针可以作为函数返回值但不能指向自动局部变量可一指向全局变量或者static局部变量">
        <title>6.
        指针可以作为函数返回值，但不能指向自动局部变量。可一指向全局变量或者static局部变量。</title>
        <para>
        </para>
      </section>
      <section xml:id="c函数调用是值传递的参数是指针时也是值传递只不过指针的值是一个地址赋值的指针值还是指针指向的对象的地址所以改变p指向的对象时会影响到外部数据但是改变指针本身的地址不会影响外部的指针外部的指针还是指向原来对象">
        <title>7.
        <font color=green>C函数调用是值传递的。参数是指针时也是值传递，只不过指针的值是一个地址，赋值的指针值还是指针指向的对象的地址。所以改变p指向的对象时，会影响到外部数据，但是改变指针本身的地址，不会影响外部的指针。外部的指针还是指向原来对象</font></title>
        <para>
        </para>
      </section>
      <section xml:id="const-int-p-和-int-const-p">
        <title>8. const int <emphasis>p 和 int </emphasis> const
        p:</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              const 在类型前面，保护的是p所指向的int值
            </para>
          </listitem>
          <listitem>
            <para>
              const 在类型后面，保护的是p本身
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=green>主要看<emphasis>的位置，星号和星号前面表示定义的指针所指向的类型。</emphasis>号后面说明是什么指针</font>
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="指针与数组">
      <title>2. 指针与数组</title>
      <section xml:id="c语言啊支持3中而且只有3种格式的指针算术运算">
        <title>1.
        C语言啊支持3中(而且只有3种)格式的指针算术运算：</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              指针加上整数；
            </para>
          </listitem>
          <listitem>
            <para>
              指针减去整数；
            </para>
          </listitem>
          <listitem>
            <para>
              两个指针相减： 得到两个指针之间的距离
            </para>
          </listitem>
          <listitem>
            <para>
              在一个不指向任何数组元素的指针上执行算术运算符会导致未定的行为
            </para>
          </listitem>
          <listitem>
            <para>
              只有在两个指针指向同一个数组时，把它们相减才有意义。
            </para>
          </listitem>
          <listitem>
            <para>
              指针比较：只有在两个指针指向同一个数组时，把它们比较才有意义。
            </para>
          </listitem>
          <listitem>
            <para>
              指向复合常量的指针： int *p = (int []){3, 0, 3, 4};
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="指针用于数组处理">
        <title>2. 指针用于数组处理</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              例子
            </para>
            <programlisting>
 #define N 10
 int a[N], sum, *p;
 sum = 0;
 for (p = &amp;a[0]; p &lt; &amp;a[N]; p++)
     sum += *p;

 尽管a数组没有a[N]这个元素，但这里是安全的，因为a[N]这个地址存在，而这个地址存的值是什么是不知道的，而循环中我们仅仅比较了a[N]的地址，而没有用到a[N]保存的值，所以是非常安全的。
</programlisting>
          </listitem>
          <listitem>
            <para>
              <emphasis>p++:
              ++的后缀优先级大于</emphasis>，所以是*(p++)。这个指向的是原来的p的值，先返回值，再加一。
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="用数组名作为指针">
        <title>3. 用数组名作为指针</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              可以用数组名作为指向数组第一个元素的指针。
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=red>虽然可以把数组名用作指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的</font>
            </para>
          </listitem>
          <listitem>
            <para>
              <font color=red>对于形式参数而言，声明为数组跟声明为指针是一样的；但对于变量而言，声明为数组和声明为指针是不同的</font>
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  声明 int
                  a[10];会导致编译器预留10个整数的空间，但声明int
                  *a;只会导致编译器为一个指针分配空间。后一种情况如果当做数组操作很危险。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              C语言允许把指针看做数组名进行取下标操作。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  当指针指向一个数组名时，可以当做是数组名来使用，也就是说可以执行下标操作。
                </para>
              </listitem>
              <listitem>
                <para>
                  记得，是将指针指向一个数组名时，否可会出现错误
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="指针和多维数组">
        <title>4. 指针和多维数组</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              多维数组在内存中的模型：C语言是按行主序列存储二维数组的；换句话说，先是0行的元素，接着是1行的元素，以此类推。使用指针可以利用这一布局。但只有老编译器支持这种操作。
            </para>
            <programlisting>
 对于 int a[NUM_ROWS][NUM_COLS]的循环
 int row, col;
 ...
 for (row = 0; row &lt; NUM_ROWS; row++)
     for (col = 0; col &lt; NUM_COLS; col++)
         a[row][col] = 0;

 但是如果把它看做一维的数组也是可以的，两个循环就成为一个循环了

 int *p;
 ...
 for (p = &amp;a[0][0]; p &lt;= &amp;a[NUM_ROWS-1][NUM_COLS-1])
     *p = 0;
</programlisting>
          </listitem>
          <listitem>
            <para>
              指针处理多维数组的行 &gt;
              为了访问到第i行的元素，需要初始化p指向数组a中第i行的元素0：p
              = &amp;a[i][0]，可以简写为 p = a [i];
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  对于任意数组a来说，a[i] 等价于 *(a +
                  i)，因此，可以推导出以上等式。
                </para>
                <programlisting>
 int a[NUM_ROWS][NUM_COLS], *p, i;
 ...
 for (p = a[i]; p &lt; a[i] + NUM_COLS; p++)
     *p = 0;
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              处理多维数组的列
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  eg
                </para>
                <programlisting>
 int a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS], i;
 ...
 for (p = &amp;a[0]; p &lt; &amp;a[NUM_COLS; p++)
     (*p)[i] = 0;
</programlisting>
              </listitem>
              <listitem>
                <para>
                  解释
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      <font color=green>这里把p声明为指向长度为NUM_COLS的整型数组的指针。在(<emphasis>p)[NUM_COLS]中，</emphasis>p是需要使用括号的；如果没有括号，编译器认为p是指针数组，而不是指向数组的指针</font>。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      因为p是指向数组的指针，所以<emphasis>p就是p指向的内容，就是那个数组本身。所以(</emphasis>p)[i]就是那个数组的第i个元素。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              <font color=red>用多维数组名作为指针</font>
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  无论数组的维数是多少都可以采用任意数组的名字作为数组的指针
                </para>
              </listitem>
              <listitem>
                <para>
                  int a[NUM_ROWS][NUM_COLS]
                  的a不是指向a[0][0]的指针，而是指向a[0]的指针
                </para>
              </listitem>
              <listitem>
                <para>
                  从C语言的观点来看，这样是有意义的，因为C语言认为a不是二维数组，而是一维数组，且这个一维数组的每个元素又是一维数组。用作指针时，a的类型是
                  int
                  (*)<link xlink:href="指向长度为NUM_COLS的整型数组的指针">NUM_COLS</link>
                </para>
              </listitem>
              <listitem>
                <para>
                  注意，二维数组的名字不是int
                  <emphasis>类型，所以有的函数调用时，需要的参数是int
                  </emphasis>时，不可以用二维数组名当做参数
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="c99-中的指针和变长数组">
        <title>5. C99 中的指针和变长数组</title>
        <blockquote>
          <para>
            指针可以指向变长数组中的元素
          </para>
        </blockquote>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              一维变长数组
            </para>
            <programlisting>
 void f(int n){
     int a[n], *p;
     p = a;
     ...
 }
</programlisting>
          </listitem>
          <listitem>
            <para>
              二维变长数组
            </para>
            <programlisting>
 void f(int m, int n){
     int a[m][n], (*p)[n];
     p = a;
     ...
 }
</programlisting>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  如果变长数组是多维的，指针的类型取决于除了第一维外每一维的长度。
                </para>
              </listitem>
              <listitem>
                <para>
                  </font color=green>C语言中每种类型的内存是固定的，声明时就会分配空间。类型要能完全确定内存的具体大小。而变长数组除外。变长数组是运行时确定的？指针指向的内存空间的大小也必须确定，编译器应该会确定指针所能访问的内存空间的界限，不会允许它操作不在它不能操作的内存空间，所以，p所指向的内存空间界限应该必须是确定的。</font>
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="问答-1">
        <title>6. 问答</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              指针的加减法并不是将数字加到指针所保存的地址，而是对它进行了缩放，例如如果p的类型是int
              <emphasis>，那么p+i通常是p加上4</emphasis>i。
            </para>
          </listitem>
          <listitem>
            <para>
              i[a] 和 a[i] 是一样的，对编译器而言，i[a] 等同于
              <emphasis>(i + a)，也就是</emphasis>(a +
              i)。但不要这样使用。
            </para>
          </listitem>
          <listitem>
            <para>
              形式参数*a和a[]是一样的，都是说明我们期望的实际参数是指针。在这两种情况下，对a进行的运算时相同的，而且在这两种情况下，可以在函数内给a本身赋新的值。C语言要求数组变量的名字是常量指针，但对于数组形式参数的名字没有这一限制。
            </para>
          </listitem>
          <listitem>
            <para>
              数组和指针可以互换准确吗？
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  不准确。数组型形式参数和指针形式参数是可以互换的，但是数组行变量不同于指针变量。从技术上说，数组的名字不是指针，C语言会在需要的时候把数组的名字转换为指针。对数组a使用sizeof时，sizeof(a)的值是数组中字节的总数，即每个元素的大小乘以元素的数量。但是，如果p是指针变量，sizeof(p)的值则是用来存储指针所需的字节数量。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="指针的高级应用">
      <title>3. 指针的高级应用</title>
      <para>
      </para>
    </section>
    <section xml:id="预处理器">
      <title>4. 预处理器</title>
      <section xml:id="预处理器的最主要能力宏定义条件编译文件包含">
        <title>1.
        预处理器的最主要能力：宏定义、条件编译、文件包含。</title>
        <para>
        </para>
      </section>
      <section xml:id="宏定义">
        <title>2. 宏定义</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              简单的宏/对象式宏
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  [#define指令 (简单的宏)] #define 标识符 替换列表
                </para>
              </listitem>
              <listitem>
                <para>
                  不要再宏定义中放置任何额外的符号
                </para>
              </listitem>
              <listitem>
                <para>
                  不要再宏定义后添加分号，否则宏替换时会加上额外的符号和分号。宏替换只是简单的文本替换
                </para>
              </listitem>
              <listitem>
                <para>
                  虽然简单宏常用于定义常量名，但是他们还有其他应用。
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      可以对C语法做小的修改
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      对类型重命名
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      控制条件编译：例如下面可能表明程序在<quote>调试模式</quote>下进行编译，并使用额外的语句输出调试信息：
                      #define DEBUG
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      宏定义中的替换列表为空是合法的。
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          解释：
                          定义宏，并在预处理过程中将其替换为空字符串（即删除）。
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          意义：这样做主要是为了标记某些内容，使程序阅读者能够清楚标记表明的意义，同时又不影响被编译的源代码。也就是说，用法同define后接两个参数，只是后一个参数为空字符串。
                        </para>
                      </listitem>
                      <listitem>
                        <para>
                          用途：
                        </para>
                        <orderedlist numeration="arabic" spacing="compact">
                          <listitem>
                            <para>
                              定义一个符号用来给#if(n)def判断。        
                               
                            </para>
                          </listitem>
                          <listitem>
                            <para>
                              多文件编译中防止头文件被重复包含。
                            </para>
                          </listitem>
                        </orderedlist>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              带参数的宏
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  定义格式： [#define指令 (带参数的宏)] #define
                  标识符(x1, x2, …, xn) 替换列表
                </para>
              </listitem>
              <listitem>
                <para>
                  标识符和左括号之间必须没有空格，否则预处理器会以为它是简单的替换。
                </para>
              </listitem>
              <listitem>
                <para>
                  标识符中的参数，在替换列表中时需要加上括号防止引起错误，最外面也要加上一个大括号，防止仅仅文本替换引起的错误。
                </para>
              </listitem>
              <listitem>
                <para>
                  带参数的宏可以包含空的参数列表： #define getchar()
                  getc(stdin)
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              宏可能导致的错误
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  宏可能会不止一次的计算它的参数，函数对他的参数只会计算一次，而宏可能会计算两次升值更多次：
                  n = MAX(i++,
                  j):这里第一个参数每次出现，都会多计算一次，因为宏只是简单的替换。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <blockquote>
              <para>
                宏定义可以包含两个专用的运算符：# 和
                ##。编译器不会识别这两种运算符，它们会在预处理时被执行。
              </para>
            </blockquote>
            <orderedlist numeration="arabic">
              <listitem>
                <programlisting>
 #define PRINT_INT(n) printf(#n &quot; = %d\n&quot;, n);  
 n之前的#运算符通知预处理器根据PRINT_INT的参数创建一个字符串字面量。 &lt;font color=green&gt;这是一个字面量，相当于把参数有复制了一下，在后面用&lt;/font&gt;
 PRINT_INT(i/J);  会变为  printf(&quot;i/j&quot; &quot; = %d\n&quot;);
</programlisting>
              </listitem>
              <listitem>
                <programlisting>
#define MK_ID(n)  i##n
MK_ID(1),预处理器首先使用实际参数替换形式参数n，接着，预处理器将i和1合并成为一个记号（i1）。

int MK_ID(1), MK_ID(2), MK_ID(3);
预处理器转变为：
int i1, i2, i3


#define GENERIC_MAX(type) type type##_max(type x, type y) { return x &gt; y ? x : y;}

GENERIC_MAX(float)
GENERIC_MAX(int)
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              宏的通用属性
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  宏的替换列表可以包含对其他宏的调用： #define PI
                  3.1415926 #define TWO_PI (2 * PI)
                </para>
              </listitem>
              <listitem>
                <para>
                  预处理器只会替换完整的记号，而不会替换记号片段，</font color=green>因此，预处理器会忽略嵌在标识符、字符常量、字符串字面量之中的的宏名</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  宏定义的作用范围通常到出现这个宏文件的文件末尾
                </para>
              </listitem>
              <listitem>
                <para>
                  宏不可以被定义两遍，除非新的定义与旧的定义完全一样。
                </para>
              </listitem>
              <listitem>
                <para>
                  宏可以使用#undef指令<quote>取消定义</quote>。 [#undef
                  指令] #undef 标识符
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              宏定义的圆括号：
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  对于在一个宏中哪里需要加圆括号有两条规则要遵守
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      如果宏的替换列表中有运算符，那么始终要将替换列表放在括号里
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      如果宏有参数，每个参数每次在替换列表中出现时都要放在圆括号里。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              创建较长的宏
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  创建较长的宏时，逗号运算符会十分有用
                </para>
                <programlisting>
 #define ECHO(S) (get(S), puts(s))
 这个宏会先读入一个字符串，再把字符串显示出来
 使用的是宏字符替换加上逗号运算符的功能
</programlisting>
              </listitem>
              <listitem>
                <para>
                  使用大括号形成复合语句：
                </para>
                <programlisting>
 #define ECHO(s) { gets(s); puts(s);}
</programlisting>
              </listitem>
              <listitem>
                <para>
                  以上两种的弊端
                </para>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      逗号运算符并不能解决所有的问题。加入一个宏需要包含一系列的语句，而不仅仅是一系列的表达式，这时逗号救起不了作用了，因为它只能连接表达式，不能连接语句。
                    </para>
                    <orderedlist numeration="arabic">
                      <listitem>
                        <para>
                          解决办法是将语句放在do循环中，并将条件设置为假，因此语句只执行一次，但注意，这里最后也要少一个分号，在替换时补全。
                        </para>
                        <programlisting>
 #define ECHO(s)  \
         do {
             gets(s);
             puts(s);
         } while (0)

 ECHO(str);  /* do { gets(str); puts(str); } while (0);*/
</programlisting>
                      </listitem>
                    </orderedlist>
                  </listitem>
                  <listitem>
                    <para>
                      但这样可能会产生错误，例如if
                      后面跟复合语句的话，大括号后面没有分号，但是写程序时写宏标识符时一个句子应该加分号。
                    </para>
                    <orderedlist numeration="arabic" spacing="compact">
                      <listitem>
                        <para>
                          解决办法，在代码里运用宏的名字ECHO是，不要再ECHO后面加分号。
                        </para>
                      </listitem>
                    </orderedlist>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              预定义宏 &gt;
              C语言有一些预定义宏，每个宏标识一个整数常量或字符串字面量。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  <emphasis role="strong">LINE</emphasis> 被编译的行号
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="strong">FILE</emphasis> 被编译的文件名
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="strong">DATE</emphasis>
                  编译的日期（格式<quote>Mmm dd yyyy</quote>)
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="strong">TIME</emphasis>
                  编译的时间（格式<quote>hh:mm:ss</quote>)
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="strong">STDC</emphasis>
                  如果编译器复合C标准（C89或C99），那么值为1
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              空的宏参数 &gt; C99
              允许宏调用中的任意或所有参数为空，当然这样的调用需要有和一般调用一样多的逗号
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  例子
                </para>
                <programlisting>
 #define ADD(x, y) (X+y)  与处理之后： i = ADD(j, k); 变成 i = (j+k),而赋值语句：i = ADD( , k);则变为 i = (+k)
</programlisting>
              </listitem>
              <listitem>
                <para>
                  空参数是#或是##时有特殊规定，空的实际参数是#的话，空参数被#<quote>字符串化</quote>，则结果为&quot;&quot;（空字符串）。
                </para>
              </listitem>
              <listitem>
                <para>
                  如果##
                  运算符之后的一个实际参数为空，它将被不可见的<quote>位置标记</quote>记号代替，把原始的记号与位置标记记号相连接，得到的还是原始的记号（位置标记记号消失了），如果连接两个位置标记记号，得到的是一个位置标记记号，宏扩展完成后，位置标记记号从程序消失。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              参数个数可变的宏
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  例子
                </para>
                <programlisting>
 #define TEST(condition, ...)  ((condition)? printf(&quot;Passed test: %s\n&quot;, condition): printf(__VA_ARGS__)
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              __func__标识符
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  __func__与预处理器无关
                </para>
              </listitem>
              <listitem>
                <para>
                  每个函数都可以访问__func__标识符，它的行为很像一个存储当前正在执行的函数的名字的字符串变量，作用相当于在函数体的一开始包含如下生命
                </para>
                <programlisting>
 static const char __func__[] = &quot;function-name&quot;
</programlisting>
              </listitem>
              <listitem>
                <para>
                  这个标识符可是让我们写出如下宏
                </para>
                <programlisting>
 #define FUNCTION_CALLED() printf(&quot;%s called\n&quot;, __func__);
</programlisting>
              </listitem>
              <listitem>
                <para>
                  __func__的另一个用法：作为参数传递给函数，让函数知道调用它的函数的名字。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="条件编译">
        <title>3. 条件编译</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              #if 和#endif
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  调试
                </para>
                <programlisting>
 #define DEBUG 1
 #if DEBUG
 ...
 #endif
</programlisting>
              </listitem>
              <listitem>
                <para>
                  在预处理过程中，#if会测试DEBUG的值，如果DEBUG不为0，预处理器将if和endif之间的语句保留#if和#endif消失，如果DEBUG是0，会将之间的语句也一起删除。
                </para>
              </listitem>
              <listitem>
                <para>
                  当#if指令会把没有定义过的标识符当做0对待，#if
                  DEBUG会失败，#if !DEBUG会成功
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              defined运算符 &gt; defined
              应用于标识符时，如果标识符是一个定义过的宏则返回1，否则返回0，defined
              长于#if指令结合使用。
            </para>
          </listitem>
          <listitem>
            <para>
              #ifdef 指令和 #ifndef &gt; #ifdef
              指令测试一个标识符是否已经定义为宏 #ifdef
              标识符。结尾需要和 #endif对应。#ifdef相当于 #if
              defined(标识符)
            </para>
          </listitem>
          <listitem>
            <para>
              #elif 和#else &gt;
              #if、#ifdef、#ifndef可以向普通的if语句那样嵌套使用
            </para>
          </listitem>
          <listitem>
            <para>
              使用条件编译
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  编写在多台机器可移植额程序
                </para>
                <programlisting>
 #if defined(WIN32)
 ...
 #elif defined(MAC_OS)
 ...
 #elif defined(LINUX)
 ...
 #endif
</programlisting>
              </listitem>
              <listitem>
                <para>
                  编写用不同的编译器的程序
                </para>
              </listitem>
              <listitem>
                <para>
                  为宏提供默认定义：先检测一个宏是否定义，若没有定义可提供一个默认定义
                </para>
              </listitem>
              <listitem>
                <para>
                  临时屏蔽包含注释的代码
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="其他指令">
        <title>4. 其他指令</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              #error
            </para>
          </listitem>
          <listitem>
            <para>
              #line
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  #line n
                </para>
              </listitem>
              <listitem>
                <para>
                  #line n <quote>文件</quote>
                </para>
              </listitem>
              <listitem>
                <para>
                  #pragma
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="问答-2">
        <title>5. 问答</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              什么常量需要定义为宏：除了0和1意外的每一个数值常量都应该定义为宏。字符串的话，在不止一次使用或可能改变的常量
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section xml:id="大型程序源文件结构">
      <title>5. 大型程序源文件结构</title>
      <section xml:id="源文件">
        <title>1. 源文件</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              把程序分成多个源文件有许多显著的优点
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  结构清晰
                </para>
              </listitem>
              <listitem>
                <para>
                  可以分别对每个源文件进行编译
                </para>
              </listitem>
              <listitem>
                <para>
                  有利于复用
                </para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="头文件">
        <title>2. 头文件</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              共享宏定义和类型定义
            </para>
          </listitem>
          <listitem>
            <para>
              共享函数原型
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  在文件foo.c中定义了函数f，则把头文件命名为foo.h
                </para>
              </listitem>
              <listitem>
                <para>
                  <font color=green>在含有函数f定义的源文件中始终包含声明函数f的头文件</font>
                </para>
              </listitem>
              <listitem>
                <para>
                  仅用于单一文件的函数不需要在头文件中声明。
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              共享变量声明
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  声明变量 ：int
                  i，这样不仅声明了i是int类型的，而且也对i进行了定义，从而使编译器为i留出了空间，为了声明而不是定义它，需要在变量的声明处放置extern关键字。
                </para>
                <programlisting>
 extern int i;
</programlisting>
                <orderedlist numeration="arabic" spacing="compact">
                  <listitem>
                    <para>
                      extern
                      告诉编译器，变量i是在程序中的其他位置定义的（很可能不在同一个源文件），因此不需要为i分配空间。
                    </para>
                  </listitem>
                  <listitem>
                    <para>
                      extern
                      可以用于所有类型的变量，在数组的声明中使用extern时，可以省略数组的长度：
                      extern int
                      a[];因为编译器不需要为数组分配空间，也就不需要知道数组的长度。
                    </para>
                  </listitem>
                </orderedlist>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              C应该注意头文件嵌套，但C++头文件嵌套很常见
            </para>
          </listitem>
          <listitem>
            <para>
              保护头文件：如果源文件包含同一个头文件两次，那么很可能产生编译错误，当头文件包含其他头文件时，这种问题十分普遍。头文件只包含变量、函数原型、宏没关系，但有类型定义，会编译错误。
            </para>
            <orderedlist numeration="arabic" spacing="compact">
              <listitem>
                <para>
                  为了防止头文件多次包含，用#ifdef和#endif指令来封闭文件的内容
                </para>
              </listitem>
            </orderedlist>
          </listitem>
          <listitem>
            <para>
              头文件中的#error指令
            </para>
            <orderedlist numeration="arabic">
              <listitem>
                <para>
                  例如用到在C89不存在的特性时，要检查编译器的版本
                </para>
                <programlisting>
 #ifndef __STDC__
 #error This header requires a Standard C compiler
</programlisting>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="把程序划分为多个文件">
        <title>3. 把程序划分为多个文件</title>
        <para>
        </para>
      </section>
    </section>
    <section xml:id="其他">
      <title>6. 其他</title>
      <section xml:id="c程序通常包含3个步骤">
        <title>1. c程序通常包含3个步骤</title>
        <itemizedlist spacing="compact">
          <listitem>
            <para>
              预处理
            </para>
          </listitem>
          <listitem>
            <para>
              编译
            </para>
          </listitem>
          <listitem>
            <para>
              链接
            </para>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="在任何需要数值的地方都可以使用具有相同类型的表达式">
        <title>2.
        在任何需要数值的地方，都可以使用具有相同类型的表达式。</title>
        <para>
        </para>
      </section>
      <section xml:id="宏">
        <title>3. 宏</title>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              当宏包含运算符时，必须用括号把表达式括起来。
            </para>
            <programlisting>
 #define RECIPROCAL_OF_PI （1.0f / 3.1415f)
</programlisting>
          </listitem>
          <listitem>
            <para>
              宏的名字只用了大写字母
            </para>
          </listitem>
        </orderedlist>
      </section>
      <section xml:id="代码规范">
        <title>4. 代码规范</title>
        <orderedlist numeration="arabic" spacing="compact">
          <listitem>
            <para>
              语句可以分开放在任意多行内
            </para>
          </listitem>
          <listitem>
            <para>
              在每个运算符的前后都放上一个空格
            </para>
          </listitem>
          <listitem>
            <para>
              每个逗号后放一个空格
            </para>
          </listitem>
          <listitem>
            <para>
              缩进
            </para>
          </listitem>
          <listitem>
            <para>
              空行可以把程序划分为逻辑单元
            </para>
          </listitem>
        </orderedlist>
      </section>
    </section>
  </section>
  <section xml:id="十四.-闲暇考虑">
    <title>十四. 闲暇考虑</title>
    <section xml:id="这个语言有哪些惯用法和模式">
      <title>1. 这个语言有哪些惯用法和模式</title>
      <para>
      </para>
    </section>
    <section xml:id="这个语言的编译解释执行机制">
      <title>2. 这个语言的编译/解释执行机制</title>
      <para>
      </para>
    </section>
    <section xml:id="泛型">
      <title>3. 泛型</title>
      <para>
      </para>
    </section>
  </section>
  <section xml:id="十五.-cc-需要考虑内存模型">
    <title>十五. C/C++ 需要考虑内存模型</title>
    <section xml:id="字面值的内存位置">
      <title>1. 字面值的内存位置</title>
      <section xml:id="对于整数类型如果出现在表达式语句中通常会成为立即数被包含在生成的代码中">
        <title>1.
        对于整数类型，如果出现在表达式语句中，通常会成为<quote>立即数</quote>，被包含在生成的代码中。</title>
        <para>
        </para>
      </section>
      <section xml:id="没有参与代码生成的常量比如用于全局变量的初始化数组声明模板参数等等哪里也不存在编译期就处理了">
        <title>2.
        没有参与代码生成的常量，比如用于全局变量的初始化、数组声明、模板参数等等，哪里也不存，在编译期就处理了。</title>
        <para>
        </para>
      </section>
      <section xml:id="其它常量通常放在静态数据区">
        <title>3. 其它常量，通常放在静态数据区。</title>
        <para>
        </para>
      </section>
      <section xml:id="字符串常量会放在一个专用的字符串池内存块中或者放在静态数据区中有些编译器还会安排在代码区一起视所用的编译器和编译选项而定">
        <title>4.
        字符串常量会放在一个专用的字符串池内存块中，或者放在静态数据区中。有些编译器还会安排在代码区一起（视所用的编译器和编译选项而定）</title>
        <para>
        </para>
      </section>
      <section xml:id="数字常量占用代码段汇编指令的操作数部分">
        <title>5. 数字常量占用代码段汇编指令的操作数部分。</title>
        <para>
        </para>
      </section>
    </section>
  </section>
  <section xml:id="十六.-之后">
    <title>十六. 之后</title>
    <section xml:id="数据库">
      <title>1. 数据库</title>
      <para>
      </para>
    </section>
    <section xml:id="网络">
      <title>2. 网络</title>
      <para>
      </para>
    </section>
    <section xml:id="图形">
      <title>3. 图形</title>
      <para>
      </para>
    </section>
    <section xml:id="框架">
      <title>4. 框架</title>
      <para>
      </para>
    </section>
    <section xml:id="库">
      <title>5. 库</title>
      <para>
      </para>
    </section>
  </section>
</section>
</article>
