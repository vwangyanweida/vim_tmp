## 快速掌握一个语言的50%
<font color=green></font>
<font color=red></font>

### 一. printf函数和基础
#### 1. printf和scanf
1. 打印浮点数时:%f,默认显示小数点后6位，如果强制%f显示小数点后p位数字，可以把.p放置在%和f之间。：%.2f
2. %m.pX格式：m和p都是可选的。如果省略p，m和p之间的小数点也要去掉。
    1.  m是最小字段宽度，如果要显示的数值所需的字符小于m，那么值在字段内是右对齐的，就是在值前面放置额外的空格
    2.  如果大于m，则会自动扩展所需尺寸。
    3. %-m.pX中，值是左对齐的，空格加在后面。
    4. 精度
        1. 如果X是d，p指明最小显示的数字个数，如果p省略，默认p为1
        2. 如果X是e，p指明小数点后应该出现的数字的个数，默认为6，如果p为0，不显示小数点。
        3. 如果X是f，“定点十进制”形式浮点数，没有之术。与e一样
        4. 如果X是g，“定点十进制”或者指数形式，p表示可以显示的有效数字，不显示尾随的0.
2. scanf：
    1. scanf第二个参数是一个指针，一定要注意。
    2. scanf会忽略所有空白字符。
    3. scanf 输入字符串时不会忽略空白字符。？？？

3. 易混淆
    1. printf的参数没有指针
    2. scanf中的格式串不能包含逗号，scanf(%d, %d, &i, &j)。如果输入第一个整数后没有跟着一个逗号，scanf会出现异常。

#### 2. 基本数据结构
1. 整数：int，unsigned int，long，long long，char
2. float， double

#### 3. 基本语法
1. 表达式
    > 表达式是表示如何计算值的公式。

    1. <font color=red>运算符</font>
        1. 算术运算符
            1. 加减乘除、求余、正负。
            2. /：当两个操作数都是整数时，运算符/会丢掉分数部分来“截取”结果。
            3. %：两个操作数都必须是整数，如果有一个不是整数，无法通过编译。
            3. / 和% 的分母不能为0.
            4. **当/和% 用于负数操作数时，C99规定，除法的结果总是向零截取的。**
        2. 关系运算符
        3. 逻辑运算符
        4. 逗号云算法
            1. 语法： 表达式1， 表达式2
            2. 解释：
                1. 逗号表达式的计算要通过两步来实现：
                   1. 计算表达式1并且扔掉计算出的值。
                   2. 计算表达式2，把这个值作为整个表达式的值。
                   3. 对表达式1的计算应该始终会有副作用，如果没有，那么表达式1就没有了存在的意义。

    2. 运算符的优先级和结核性
        1. 最高：正负
        2. 最低： + - 
        3. <font color=green>二元算术符是左结合的</font>
        4. <font color=green>一元算术符是右结合的，复制操作符=也是右结合的。</font>
        5. <font color=red>赋值运算符=在C中是运算符，换句话说，复制操作符产生结果，就像如果两个数相加产生结果一样。赋值表达式v=e的值就是赋值运算后v的值。这个表达式是产生一个结果的，所以可以连等就是这个原因。</font>
        6. 关系运算符低于算术运算符，关系运算符是左结合的。
        7. 判等运算符，==。左结合，优先级低于关系运算符。
        8. 逻辑运算符：!, &&, ||.
            1. 结果为0或者1
            2. 将任何非零操作数作为真值来处理，同时将任何零值操作数当做假来处理。
            3. && 和|| 都对操作数进行“短路”计算。短路操作的副作用是不计算右边的表达式时，如果右边的表达式改变了变量的值，就没有计算这个表达式
            4. ! 的优先级和一元正负号一样。&& 和||优先级低于 关系运算符好判等运算符。

    3. 左值
        > 左值表示存储在计算机内存中的对象，而不是常量或计算的结果，变量时已知的唯一左值。

        1. 赋值运算符要求左操作数必须是左值。 
    
    4. 自增自减
        1. i++：先用i的原始值，稍后再自增i。稍后是指在校一条指令执行之前。  
        2. ++i：立即自增i。
        3. <font color=red>后缀++和后缀--比一元的正号和负号优先级高而且都是左结合的</font>
        4. <font color=red>前缀++和前缀--和一元的正号和负号优先级相同而且都是右结合的</font>
        
2. 语句
    1. 选择语句
        1. if
            1. 级联式if。 if …… else if …… else
            2. 避免悬空式else。最好加上大括号。
            3. 条件表达式： 表达式1 ? 表达式2 : 表达式3
                1. 条件运算符的优先级低于前面介绍过的所有运算符。

            4. 布尔值：C99 定义了一个_Bool类型，其实是int但只能赋值0和1.
                1. 一般来说，往_Bool变量中存储非零值会导致变量赋值为1；
                    
                        flag = 5; /*flag is assigned 1*/
                2. 除了_Bool这个类型外，C99还提供了一个新的头文件<stdbool.h>,这使得操作布尔值更加容易。该头文件提供了bool宏，用来代表_Bool.

                        #include<stdbool.h>
                        flag = false
                        flag = true

        2. switch
            1. 语法：
            
                    switch (表达式) {
                        case 常量表达式: 语句；
                                语句；
                                语句；
                                break；
                        case 常量表达式: 语句；
                                语句：语句；
                                语句；
                                break；
                                ……
                        default：语句；
                                 语句；
                                 break；
                    }

            2. switch 表达式必须是整形表达式，C语言吧字符也当成字符，所以字符也可以。浮点数和字符串不可以。
            3. 常量表达式不能包含变量和函数调用，也必须是整数。

    2. 重复语句
        1. while

                while （表达式） 语句

        2. do

                do 语句 while (表达式);  注意这里有分隔号。

        3. for
            1. 语法
                    for （表达式1；表达式2；表达式3） 语句

            2. for 条件表达式可以省略其他语句。但分号要保留。

            3. for语句声明的变量不可以在循环外访问。在循环外不可见。

    3. 跳转语句
        1. break
        2. continue
        3. goto
            1. 语法：
                
                    标识符 : 语句
                    goto 标识符；

            2. 一般不用，在多层循环嵌套时，因为break跳不出最外层循环，可以使用。

    4. 复合语句
        > 几条语句组合成一条语句
        
    5. 空间语句
        > 不执行任何语句

        1. 和python 的pass类似。 仅仅只有一个 分号： ；。
        2. 空语句要单独一行写，否则阅读时会混淆。

3. 函数
    1. 调用函数时，是将实参的值复制给形参的。所以函数如果想改变函数体外的变量需要使用引用或者指针。
    2. 函数定义
        1. 函数的返回类型
            1. 函数不能返回数组，但关于返回类型没有其他限制。
            2. 如果省略返回类型，C89会假定为int，但C99是不合法的。
    3. 函数声明
        > 在调用一个函数前，需要先声明函数或者定义函数。

        1. 语法：   [函数声明]  返回类型  函数名 (形式参数)
        2. 函数声明和函数定义一定要一致。

    4. <font color=green>C语言中，实际参数是通过值传递的</font>

    5. 实际参数
        1. 数组型实际参数
            1. 当形式参数是一维数组时，可以不说明数组的长度

                    int f(int a[])
                    {
                        ……
                    }
            2. <font color=red>C语言没有为函数提供任何简便的方法来确定传递给它的数组的长度；如果函数需要，我们必须把长度作为额外的参数提供出来</font>                    
    
                    int sum_array(int a[], int n)
                    {
                        int i, sum = 0;
                        for (i = 0; i < n; i++)
                            sum += a[i];
                        return sum;
                    }

            3. 在调用函数时，把数组名传递给函数时，不要在数组名的后边放置方括号，形参需要加。
            4. 在调用函数时，数组型实际参数的元素可以修改。值传递不包括数组名是因为数组名实际是一个指针。
            5. 如果形式参数是多维数组，生命参数时只能省略第一维的长度。

                    #define LEN 10
                    int sum_two_dimensional_array(int a[][LEN], int n)
                    {
                    }

            6. 变长数组形式参数
                > C99 增加的变长数组允许我们使用非常量表达式指定数组的长度，变长数组也可以作为参数。

                1. eg

                        int sum_array(int n, int a[n])
                        {
                        }

                2. 注意:确定数组长度的变量一定要出现在数组前面，因为运行时当执行到为数组分配空间时，数组长度需要确定，所以n的值当时应该已经知道。而且，如果n在后面会引起使用未定义的变量。
                3. 函数声明(函数原型)有好几种写法：
                    1. int sum_array(int n, int a[n]);
                    2. int sum_array(int n, int a[*]); //星号的使用告诉编译器--数组的长度与形式参数列表中前面的参数相关。
                    3. int sum_array(int, int [*]);
                    4. int sum_array(int n, int a[])
                    5. int sum_array(int, int []);

                4. 变长数组形式参数的长度可以是任意表达式
                    1. int sum_two_dimensional_array(int n, int m, int a[n][m]);

            7. <font color=red>在数组参数声明中使用static</font>
                1. C99允许在数组参数声明中使用关键字static。
                2. 例子：将static放在数字3之前表明数组a的长度至少可以保证是3：
                    
                        int sum_array(int a[static 3], int n)
                        {
                        }
                3. static 不会对程序的行为有任何影响，static的存在只不过是一个“提示”，C编译器可以据此生成更快的指令来访问数组。
                4.例如如果编译器知道数组总是具有某个最小值，那可他可以在函数调用时预先从内存中取出这些元素值，而不是在遇到函数内部实际需要用到这些元素的语句时采取出相应的值。
                5. <font color=red>如果数组名参数是多维的，static仅可用于第一维。</font>

            8. 复合字面量
                > 复合字面量是通过制定其包含的元素而创建的没有名字的数组。

                1. total = sum_array((int[]){3, 0, 4, 5, 2}, 5);
                2. 函数内部创建的复合字面量可以包含任意的表达式，不限于常量
                    
                        total = sum_array((int []){2*i, i+j, j*k}, 3);
                3. 复合字面量可以使用初始化式、可以不提供完全的初始化(未初始化的元素默认为0)
                4. 复合字面量是左值 ，所以元素是可以改变的，如果要求是“只读”的，可以在类型前加上const，如(const int []){4, 5}.

4. 程序终止
    1. main 函数的返回类型是int
    2. main函数返回的值是状态码，在某些操作系统中程序终止时可以检测到状态码。
    3. exit函数，<stdlib.h>头文件。 传递给exit的参数和main函数返回值具有相同含义。
    4. main函数中的语句 return表达式；等价于 exit(表达式)
    5. return和exit的差异：不管那个函数调用exit函数都会导致程序终止，return语句仅当有main函数调用时才会导致程序终止。
    6. reurn后可以跟表达式，return会先计算表达式再返回。return后可以跟三元操作符。

5. 问答
    1. 编译器把不跟圆括号的函数名看做是指向函数的指针。
    2. 为什么要提供函数原型，只要把所有函数的定义放置在main函数之前，不就没有问题了吗？
        1. 答：错。
            1. 某些函数相互调用，这时无论先定义那一个都会导致问题
            2. 需要仔细斟酌函数定义的顺序以满足调用顺序
            3. 程序达到一定规模，在一个文件中放置所有函数是不可行的。

    3. 为什么可以留着数组中第一维的参数不进行说明，但是其他维数必须说明呢？
        1. 答：
            1. 传递的数组名其实是把指向数组的第一个元素的指针传递给了函数，而编译器计算a[i] 的地址时，
            方法是用i乘以每个元素的大小并加到a表示的地址上。
            2. 多维数组的计算方式是：a[i][i]的地址是：i乘以数组a的每行的大小加上i乘以a每一个元素的大小并加到a表示的地址上，所以必须需要数组每一行的大小。
            3. 所以底线是程序员必须声明数组a拥有的列的数量。
    4. 如果函数f1调用函数f2，而函数f2又调用了f1，这样合法吗？
        1. 答：合法，这是一种间接递归的形式。

#### 3. 主要语言构造
1. 指令	
	> 我们把预处理器执行的命令成为指令
	
    1. 所有指令都以#字符开始，指令默认只占一行，每条指令的结尾没有分号或其他特殊标记。

2. 函数
	> 函数类似于其他语言的“过程”或“子例程”，它们是用来构建程序的构建块。

3. 语句
	>语句是程序运行时执行的命令
	
	1. <font color=red>C语言规定每条语句都要以分号结尾,但是有一个例外：复合语句就不以分号结尾。</font>
	2. <font color=green>指令因为多是一行，所以不用分号结尾，而语句可能跨越多行，需要表示分隔</font>
	
4. 注释
    1. //单行
    2. ```/*  */```可以有多种方式。
    
5. 变量和赋值
    1. 类型：
       > 类型用来说明变量所存储的数据种类
       
        1. <font color=red>每一个变量都必须有一个类型</font>
        2. <font color=green> 类型告诉编译器此变量需要占据多大的内存空间，类型确定了，C语言变量的存储空间大小就确定了。</font>
        3. <font color=green>类型会影响变量的存储方式以及允许对变量进行的操作</font>

    2. 声明
        1. <font color=green>C语言使用变量之前必须对其进行声明</font>
        2. main函数包含声明时，必须把声明放置在语句之前，函数和程序块也一样。
        3. C++和Java程序中在使用时才声明变量。
        4. 作用
            1. 告诉编译器，这个名字已经匹配到一块内存空间。
            2. 告诉编译器，这个名字已经预定了，其他地方不能在使用它声明变量或对象名。
        5. 声明可以多次，定义只能一次，变量的生命和定义是一样的，一般用在函数声明和定义上。
        6. 除了动态内存，变量在声明时就分配了内存空间。

    3. 赋值
        > 变量通过赋值的方式获得值
      
    4. 初始化
        > <font color=green>当程序执行时，某些变量会被自动初设置为0，而大多数变量则不会，没有默认值并且尚未在程序中被赋值的变量时未初始化的。</font>
        
        1. <font color=red>方位未初始化的便令，可能会得到不可知的结果</font>
        2. 解决方法
            1. 在变量声明中加入初始值。
                1. int height = 8； 8 是一个初始化式
                2. 在同一个声明中可以对任意数量的变量进行初始化。
                    int height = 8，length = 12， width = 10；
                3. 2中的每个变量都有值，而接下来只有width有值：
                    1. 只有width初始化：int height，length， width = 10；
            2. 用赋值的方法给变量赋初始值。

    5. 读入输入
        1. scanf：
            1. printf和scanf的f含义相同都是“格式化”的意思。
            2. printf和scanf都需要使用**格式串**来制定输入或输出的形式
            3. 之所以这样是因为输入和输入都需要知道数据的类型。

    6. 定义常量的名字
        > 当程序含有常量时，建议给这些常量命名。
        
        1. 可以使用宏定义来给常量命名：
            ```#define INCHES_PER_POUND 16```

    7. 标识符
        1. 一般标识符遵循只是用小写的规范，必要还可以插入下划线或驼峰命名

6. C89关键字
    1. 有关数据“模子”的关键字：void、char、short、int、long、float、double、sizeof；
    2. 有关数据符号的关键字：signed、unsigned；
    3. 构造类型：struct、union、enum、typedef；
    4. 有关存储与生命周期的类型：auto、static、extern、register、const、volatile；
        1. register
            1. 说明： 这个关键字请求编译器尽可能的将变量存放在CPU内部的寄存器中，而不是通过内存寻址访问以提高效率（是尽可能，不是绝对）。
            2. 解释：寄存器其实就是一块一块小的存储空间，只不过其存储速度比内存快得多，但是价格昂贵。
            3. 注意：
                1. register变量必须是一个单个的值，并且其长度必须小于或等于整形的长度。
                2. register变量可能不存在内存中，所以不能用取地址运算符“&”来获取register变量的地址。

        2. static；详见mybase。
            1. 说明：声明静态变量。
            2. 作用：
                1. 修饰变量：static可以修饰局部变量和全局变量，它们都存放在内部的静态区中。
                    1. 静态全局变量：作用域仅限于变量被定义的文件中，其他文件即使使用extern声明也不能使用它。准确的说：作用域是从定义之处开始到文件结束。在定义之处前面的那些代码行也不能使用它，想要使用就得在前面再加extern***。
                    2. 静态局部变量：作用域仅限于该函数里，该文件中的其他函数也用不了。虽然局部变量的生命周期随着函数的结束而终止，但是因为被static修饰的变量总是存在内存的静态区，所以即使这个函数运行结束，这个静态变量的值也不会被销毁，函数下次使用时仍然能用到这个值。
            3. 注意，static的生命只执行一次，下次就从内存中找变量的值。

        3. 符号关键字： unsigned和signed
            1. 说明：最高位如果是1，表明这个数是负数，其值为除最高位以外的剩余位的值加上“-”号；最高位如果是0，表明这个数是正数，其值为除最高位以外的剩余位的值。

        4. const
            1. 说明：const是constant的缩写，表示恒古不变。被const修饰的变量称为常变量，准确来说应该是只读的变量
            2. 作用：
                1. 修饰只读变量：定义const只读变量，具有不可变性。
                    1. const int Max = 100；
                    2. 释：<font color=green>const修饰的只读变量必须在定义的同时初始化，因为定义后就不能再被改变了。</font>
                    3. int Array[Max];
                    4. 释：这样编译时会报错，<font color=green>数组下标只能是常量</font>，即使常变量也不可以，但是宏常数可以。
                2. 修饰数组
                3. 修饰指针
                4. case 后面的数字不可以用const 修饰，因为case后面只能是常量、字符型常量和常量表达式

        5. volatile
            1. 说明：volatile是易变、不稳定的意思。
            2. 作用：用volatile修饰的变量可以被某些编译器未知的因素更改，即更新数据，未知的因素如操作系统、硬件或者其他线程等。
            3. 例子1：

                    int i = 10;
                    int j = i;//1）语句
                    int k = i;//2）语句

                分析：编译时编译器认为i的值没有发生变化，所以在1）语句时从内存中取出i的值赋给j后并没有被丢掉，在2）语句时继续用这个值给k赋值，而不生成汇编代码重新从内存里取出i的值。

           4. 例子2：

                    volatlie int i = 10;
                    int j = i;
                    int k = i;
                
                分析：例2与例1不同的是，volatile关键字告诉编译器，i的值随时可能发生变化，则每次用i，编译器都会生成汇编代码从内存中取i的值。

            5. 问题：const volatile int i = 10;这行代码有没有问题？如果没有，那么i到底是什么属性？
            6. 答：没有问题。因为const表示常量语义，被const修饰的对象在所在的作用域里无法进行修改；volatile表示易变的，即在运行期对象可能在当前程序上下文的控制流以外被修改。发生易变的情况，如：在多线程中。被其他线程修改；对象所在的存储器可能被多个硬件设备随机修改等情况。例如，只读的状态寄存器，它是volatile属性，因为它可能被意外的修改。但是，同时它也具有const属性，因为它修饰的内容只能被读而不能被写。可知：它们控制的范围不同，被const修饰的对象在程序本身内不能修改，而被volatile修饰的对象可能在本程序外被修改。所以，const和volatile一起使用没有问题。
                            
    5. 有关语句的类型：if、else、for、while、do、switch、case、fault、goto、break、continue、return

7. C99关键字
    1. _Bool
        > bool 类型变量，等价于unsigned char，只有0和1
        
        1. 头文件：<stdbool.h>

    2. _Complex
        > 对于C99 标准定义, 存在 float _Complex, double _Complex, long double _Complex 复数类型.
          
        1. 头文件: <complex.h>
        2. 其实在复数类型中，gcc标准实现
        
            ```#define complex _Complex```

    3. _Imaginary
        > 虚数类型,_Complex复数类型的虚部。关键字系统保留，我们无法使用。

    4. inline
        > 内联函数,从C++中引入的概念. 就是将小函数直接嵌入到代码中. C的代码损耗在于函数的进出栈. 要是可以推荐用内联函数替代宏. 宏能不用就不用. 函数声明的时候不要加inline 需要加extern, 定义的时候需要加inline
        
        1. 例子

                extern cjson_t cjson_newtstr(tstr_t str);

                inline cjson_t 
                cjson_newtstr(tstr_t str) {
                    str->len = _cjson_mini(str->str);
                    return _cjson_parse(str->str);
                }

                // 还有就是和static 一起使用
                static inline int _sconf_acmp(tstr_t tstr, struct sconf * rnode) {
                    return strcmp(tstr->str, rnode->key);
                }
                
    5. restrict

        > 这是很装逼的关键字用于编译器优化. 关键字restrict只用于限定指针；该关键字用于告知编译器，
        > 所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；
        > 这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。
            
        1. 演示
            1. 摘自GCC 的 string.h中

                    extern void *mempcpy (void *__restrict __dest,
                                          const void *__restrict __src, size_t __n)
                         __THROW __nonnull ((1, 2));
                
            2. 正式用法

                    // 简单演示用法, GCC 和 VS 都是 __restrict 推荐加在 * 后面
                    static void _strlove(char * __restrict dest) {
                        *dest = '\0';
                    }
                    
8. C11关键字
    1. _Alignas
        1. 解释: 内存对齐的操作符，需要和_Alignof配合使用。
        2. 演示：

                #ifndef __cplusplus

                #define alignas _Alignas
                #define alignof _Alignof

                #define __alignas_is_defined 1
                #define __alignof_is_defined 1

                #endif

                #include <stdio.h>
                #include <stdalign.h>

                struct per {
                    int age;
                    double secl;
                    char sex;
                };

                int main(int argc, char * argv[]) {
                    char c[100];
                    alignas(struct per) struct per * per = (struct per *)&c;
                    printf("per = %p, c = %p.\n", per, c); 

                    return 0;
                }

    2. _Alignof
        1. 解释： 得到类型和变量的对齐方式.
        2. 演示：
        
            printf("alignof(struct per) = %zd.\n", alignof(struct per));
            
    3. _Atomic
        1. 解释:
        　　原子操作, 原子锁. gcc 很早就支持. 详细用法可以参照 CAS https://sanwen8.cn/p/18dZQie.html讲的可以
        2. 演示：

            	#include <stdio.h>
            	#include <stdatomic.h>

            	int main(int argc, char * argv[]) {
                
                	_Atomic int hoge = ATOMIC_VAR_INIT(100);
                	int piyo = atomic_load(&hoge);  
                	printf("piyo = %d.\n", piyo);
                	piyo += 2;
                	atomic_store(&hoge, piyo);
                	printf("hoge = %d.\n", hoge);

                	return 0;
            	}
            
    4. _Generic
        1. 解释：C的泛函机制，高级函数宏
        2. 演示：
            
                #include <math.h>
                #include <stdio.h>
                #include <stdlib.h>

                #define ABS(x) _Generic((x), int:abs, float:fabsf, double:fabs)(x)

                //
                // 测试 C11 语法
                //
                int main(int argc, char * argv[]) {
                    
                        int a = 1, b = 2, c = 3;
                    
                        _Generic(a + 0.1f, int:b, float:c, default:a)++;
                        printf("a = %d, b = %d, c = %d\n", a, b, c); 

                        printf("int abs: %d\n", ABS(-12));
                        printf("float abs: %f\n", ABS(-12.04f));
                        printf("double abs: %f\n", ABS(-13.09876));

                        return EXIT_SUCCESS;
                }
            
    5. _Noreturn
        1. 解释:
        　　1. 修饰函数,绝对不会有返回值. _Noreturn 声明的函数不会返回. 引入此新的函数修饰符有两个目的:
                1. 消除编译器对没有 return的函数的警告. 
                2. 允许某种只针对不返回函数的优化.

        2. 演示:

	            _Noreturn void suicide(void) {
	                abort(); // Actually, abort is _Noreturn as well
	            }

        3. 再扯一点, GCC中等同于 __attribute__((__noreturn__)), 在VC中相似功能是 __declspec(noreturn).
            1. 它不是说函数没有返回值，而是说一旦你调了这个函数，它永远不会返回。一些函数是永远不会返回的，
            2. 比如 abort或者 exit之类，调用它们就意味着结束程序. 所以 warning就显得没有必要.
        
    6. _Static_assert
        1. 解释:
            编译器期间断言, 当 #if #error 搞完毕(预编译)之后, 编译器断言. assert是运行时断言.用的时候看具体的需求.
        2. 演示:

	            _Static_assert(__STDC_VERSION__ >= 201112L, "C11 support required");
	            // Guess I don't really need _Static_assert to tell me this :-(

    7. _Thread_local
        1. 解释：_Thread_local是新的存储类修饰符, 限定了变量不能在多线程之间共享。
        2. 演示:

	            _Thread_local static int i;
	            // Thread local isn't local!
	            语义上就是线程的私有变量.

9. 程序结构
    1. 局部变量
        > 把在函数体内声明的变量称为该函数的局部变量。
        
        1. 性质
            1. 自动存储期限。
                > 变量的存储期限是在变量存储单元存在期内程序执行的部分。

                1. 局部变量的存储单元是在包含该变量的函数被调用时“自动”分配的，函数返回时收回分配。
            
            2. 块作用域
                > 变量的作用域是可以应用该变量的程序文本的部分，从声明变量到所在的函数体的末尾。

        2. 静态局部变量
            > 在局部变量声明中放置单词static可以使变量具有静态存储期限而不再是自动存储期限。

    2. 外部变量
        1. 性质
            1. 静态存储期限
            2. 文件作用域

    3. 程序块 
        1. 声明： [程序块]  {多条声明  多条语句};
        2. 例如

                if (i > j) {
                    int tmep = i;
                    i = j;
                    j = tmep;
                }
        3. 默认情况下，声明在程序块中的变量的存储期限是自动的：进入程序块时，为变量分配存储单元，退出程序块时收回分配的空间。变量具有块作用域，也就是说，不能再程序块外引用。
        4. 注意这是C语言里特有的程序块，大括号括起。python里没有这种结构。

    4. 作用域

### 二.高级数据结构 
#### 1. 数组和集合类
1. 数组
    > 数组是含有多个数据值的数据结构，并且每个数据结构具有相同的数据类型。

    1. 其他变量基本变量都是**标量**，标量具有保存单一数据项的能力。
    2. C语言一共有两种聚合类型：数组和结构
    3. 一维数组
        1. 声明：需要指明数组元素的类型和数量：```int a[10];```
        2. 数组的元素可以是任意类型，数组的长度可以用任何(整数)常量表达式指定，因为程序以后改变时可能需要调整数组的长度，所以较好的方法是用宏来定义数组的长度：

                #define N 100
                。。。
                int a[N];
        3. 数组初始化
            1. 数组初始化式：
                1. int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
                2. 初始化式比数组短，数组剩余元素为0： int a[10] = {1, 3, 4}
                3. 利用2可以将数组初始化为一个值：int a[10] = {0}
                4. 初始化式完全为空是非法的。
                5. int a[] = {1, 2, 3, 4, 5}编译器会利用初始化式的长度来确定数组的大小。**数组仍然有固定数量的元素，这和明确指定长度效果一样**
            
            2. 指定初始化式
                1. 使用场景：数组中只有相对较少的元素需要进行显示的初始化，其他元素进行默认赋值。
                2. C99中的 指定初始化可以解决这一问题
                    
                        int a[15] = {[2] = 29, [9] = 7, [14] = 48};
                        括号里的数字成为指示符
                        指示符必须是整型常量表达式

                3. 指定初始化式还有一个优点：赋值的顺序不再是一个问题。

                        int a[15] = {[14] = 29, [9] = 7, [1] = 48};
                4. 初始化式可以同时使用老方法和新方法

                        int c[10] = {5, 1, 9, [4] = 3, 7, 2, [8] = 6};
        
        4. 对数组使用sizeof
            1. 确定数组的大小： sizeof(a)
            2. 确定数组元素的大小： sizeof(a[0])
            3. 确定数组长度： sizeof(a) / siezeof(a[0])

    4. 多维数组
        > C语言中的多维数组扮演的角色相对较弱，这主要是因为C语言Wie存储数据提供了更加灵活的方法：指针数组。

        1. 多维数组初始化
            1. 嵌套一维数组初始化式

                    int m[5][9] = {{1, 1,1,……},{0,1, 2, 2,……},……}

                    每个内部初始化提供了矩阵中的一行的值

                1. 没有填满整个数组的话，省略的部分初始化为0
                2. 可以省略内层的大括号，编译器一旦发现数组足以填满一行，它就开始填充下一行。
                3. C99指定初始化式也有用：

                        double ident[2][2] = {[0][0] = 1.0, [1][1] = 1.0};
    3. 常量数组
        > 无论一维数组还是多维数组，都可以在声明最开始处加上单词const而成为"常量"

        1. 程序不应该对声明为const的数组进行修改。编译器能够检测到直接修改某个元素的意图。

    4. 变长数组
        > 数组变量的长度必须用常量表达式进行定义，但是在C99中，有时候也可以使用非常量表达式。
        > 声明变长数组的时候可以用变量表示数组里的存储区个数，如果程序多次运行则每次运行的时候变长数组里包含的存储区个数都可能不同。但是某次程序运行中变长数组里的存储区个数不变。
        
        1. **变长数组不可以初始化，编译会出错，如果对变长数组赋值只能使用循环语句进行循环赋值**
        2. eg

                #include <stdio.h>
                int main(){
                    int num = 0;
                    printf("请输入一个整数：");
                    scanf("%d", &num);
                    int arr[num];
                    printf("sizeof(arr) = %d\n", sizeof(arr));
                    return 0;
                }

    5. 问答
        1. 如果试图用赋值运算符把一个数组复制到另一个数组中，编译器将给出出错消息，哪里错了？
        2. 答：这个需要用到C语言里的数组和指针之间的特殊关系，后面会解答。
            1. 把一个数组复制到另一个数组最简单的实现方法是利用循环对数组元素逐个进行赋值。

                    for (i = 0; i < N; i++)
                        a[i] = b[i]
            2. 另一种可行的方法是使用来自<string.h>头文件的memcpy(意思是：内存复制).
            
#### 4. 泛型

### 三. 字符串处理：替换，查找、截断
#### 1. Regex
#### 2. Parser
#### <font color=green>3. 字符编码</font>

### 四. 基本面向对象或函数式编程的特征
#### 1. 继承
#### 2. 多态
#### 3. Lambda 函数

### 五. 调试：TDD技能
#### 1. 异常
#### 2. 错误处理
#### 3. 断言
#### 4. 日志
#### 5. 调试支持
#### <font color=green>6. 单元测试</font>

### <font color=green>六. 运行时</font>
#### 1. 程序代码和可执行代码的组织机制
#### 2. 运行时模块加载
#### 3. 符号查找机制

### 七. 流
#### 1. 基本输入输出
#### 2. 文件处理
#### 3. 输入输出流类的组织

### 八. 事件驱动
#### 1. callback 方法调用
#### 2. 如何支持事件驱动编程模型
1. .NET 的delegate，Java的anonymous inner class，Java 7的closure，C++OX的tr1::function/bind……等各种语言都会在这里下足功夫。

### 九. 序列化和反序列化
#### 1. 缺省机制

### 十. regex和XML处理问题，可以跳过

### 十一. 并发
#### 1. 线程
#### 2. 进程
#### 3. 并发
#### 4. 异步调用

### 十二. <font color=green>动态编程</font>
#### 1. 反射
#### 2. 元数据编程
#### 3. 数据和程序之间的相互转化机制
#### 4. 运行时编译和执行的机制

### 十三. 语言常用的特色feature
#### 1. 指针
1. 指针变量
    1. 大多数现代计算机都讲内存分割为字节，每个字节8位。
    2. 指针是变量的初始地址。
    3. 指针的取值范围可能不同与整数的范围，所以一定不能用普通整数型变量来存储地址，但是可以用指针变量。
    4. 指针就是地址，而指针变量就是存储地址的变量。

2. 指针变量的声明
    1. int *p,说明p是指向int类型对象的指针变量。<font color=green>这里用术语对象来代替变量，是因为p可以指向不属于变量的内存区域。</font>
    3. 每个指针变量只能指向一种特定类型(引用类型)的对象。

3. 取地址符
    1. 取地址符: &
    2. 间接寻址: *
    3. 如果p指向i，*p就是i的别名。
    4. <font color=red>不要把间接寻址运算符用于未初始化的指针变量。如果指针变量p没有初始化，那么视图使用p的值会导致未定义的行为</font> 
        1. 例如： int *p; printf("%d", *p);
        2. 如果p恰好具有有效内存地址，那么会更改那个地址的数据
        3. 如果p指向的内存单元属于操作系统，那么很可能导致系统崩溃。

4. 指针赋值
    1. <font color=green>C语言允许使用赋值运算符进行指针的复制，前提是两个指针具有相同的类型</font>
        1. int i, j, *p, *q; p = &i; q = p;
        2. q = p 是将p的内容(即i的地址)复制给q，效果是把q指向p所指向的地方。

#### 2. 指针与数组

#### 3. 指针的高级应用

#### 4. 其他
1. c程序通常包含3个步骤
    - 预处理
    - 编译
    - 链接

2. 在任何需要数值的地方，都可以使用具有相同类型的表达式。

3. 宏
    1. 当宏包含运算符时，必须用括号把表达式括起来。
        
        	#define RECIPROCAL_OF_PI （1.0f / 3.1415f)

    2. 宏的名字只用了大写字母

4. 代码规范
    1. 语句可以分开放在任意多行内
    2. 在每个运算符的前后都放上一个空格
    3. 每个逗号后放一个空格
    4. 缩进
    5. 空行可以把程序划分为逻辑单元

### 十四. 闲暇考虑 
#### 1. 这个语言有哪些惯用法和模式 
#### 2. 这个语言的编译/解释执行机制
#### 3. 泛型

### 十五. C/C++ 需要考虑内存模型

### 十六. 之后
#### 1. 数据库 
#### 2. 网络
#### 3. 图形
#### 4. 框架
#### 5. 库


