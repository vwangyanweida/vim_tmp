# 快速掌握一个语言的50%: C++
<font color=red></font>
<font color=green></font>

## 一. 基础
### 1. 基本数据结构
1. 类型转换
    1. <font color=red>当我们赋给无符号数类型一个超出它表示范围的值时，如果是初始值对无符号数类型表示的数值总数取模后的余数。</font>
    2. 可能会出现无意对无符号数赋一个负值：
        1. 当一个算术表达式既有无符号数又有int值时，那个int值就会转换成为无符号数。
                
                unsigned u = 10;
                int i = -42
                std::out << i + u << std::endl;  //如果int占32位，输出4294967264

        2. 当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

                unsigned u1 = 42， u2 = 10；
                std::cout << u1 - u2 << std::endl;  // 正确：输出32
                std::cout << u2 - u1 << std::endl;  // 正确：不过输出是结果取模

        3. 编译器不管结果的类型，只遵循类型转换，计算时，强制转换类型，然后把值当做无符号数，可能出错

        4. 无符号数不会小于0，这一事实同样关系到循环的写法。

                for (unsigned u = 10; i >= 0; i--)
                    ...
                // 错误，unsigned永远不会小于0

        5. 总结切勿混用带符号数和无符号数
            > 如果表达式里既有带符号数和无符号类型，带符号数会自动转化为无符号数，结果也是无符号数类型，如果出现负数，则出错。

2. 变量
    1. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
    2. 初始化
        - int units_sold = 0;
        - int units_sold = {0}; 
        - int units_sold(0);
        - int units_sold{0};
    3. 列表初始化：
        1. 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器报错。
            
                long double = 3.1415926;
                int a{ld}, b = {ld};  //错误：转换未执行，因为存在丢失信息的危险。
                int(ld), d = ld;

            1. <font color=red>列表初始化可能是一个精确初始化，不可以以丢失精确度的代价来强制转换。</font>

    4. 声明

	5. const 限定符
		1. const 对象尽在文件内有效,除非声明和定义都加上extern
		2. 引用类型必须与其所对引用的对象类型一致,但有两个例外:
			1. const int &i = (double) 2.3
				1. 在初始化常量引用时允许任意表达式作为初始值,只要该表达式的结果能转换为引用类型即可
				2. 
					1. 例子
					
							double dval = 3.14;
							cons int &ri = dval;

							const int temp = dval;
							const int &ri = temp;
### 2. 基本语法
### 3. 主要语言构造

## 二.高级数据结构 
### 1. 数组和集合类

## 三. 字符串处理：替换，查找、截断
### 1. Regex
### 2. Parser
### <font color=green>3. 字符编码</font>

## 四. 基本面向对象或函数式编程的特征
### 1. 继承
### 2. 多态
### 3. Lambda 函数

## 五. 调试：TDD技能
### 1. 异常
### 2. 错误处理
### 3. 断言
### 4. 日志
### 5. 调试支持
### <font color=green>6. 单元测试</font>

## <font color=green>六. 运行时</font>
### 1. 程序代码和可执行代码的组织机制
### 2. 运行时模块加载
### 3. 符号查找机制

## 七. 流
### 1. 基本输入输出
### 2. 文件处理
### 3. 输入输出流类的组织

## 八. 事件驱动
### 1. callback 方法调用
### 2. 如何支持事件驱动编程模型
1. .NET 的delegate，Java的anonymous inner class，Java 7的closure，C++OX的tr1::function/bind……等各种语言都会在这里下足功夫。

## 九. 序列化和反序列化
### 1. 缺省机制

## 十. regex和XML处理问题，可以跳过

## 十一. 并发
### 1. 线程
### 2. 进程
### 3. 并发
### 4. 异步调用

## 十二. <font color=green>动态编程</font>
### 1. 反射
### 2. 元数据编程
### 3. 数据和程序之间的相互转化机制
### 4. 运行时编译和执行的机制

## 十三. 语言常用的特色feature

## 十四. 闲暇考虑 
### 1. 这个语言有哪些惯用法和模式 
### 2. 这个语言的编译/解释执行机制
### 3. 泛型

## 十五. C/C++ 需要考虑内存模型

## 十六. 之后
### 1. 数据库 
### 2. 网络
### 3. 图形
### 4. 框架
### 5. 库

